<!DOCTYPE html>
<html lang="en">
<head>
          <title>DatasFrame</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
        <link rel="stylesheet" href="./theme/css/main.css" />
        <script src="//code.jquery.com/jquery-2.2.2.min.js"></script>




</head>

<body id="index" class="home">
    <nav>
      <a href=".">Home | </a>
      <a href="/archives.html">Archive | </a>
      <a href="/categories.html">Categories | </a>
      <a href="/pages/about.html">About | </a>
      <a href="https://tomaugspurger.github.io/feeds/all.rss.xml">RSS</a>
    </nav>

<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="./categorical-pipelines.html" rel="bookmark"
         title="Permalink to Pipelines and Categoricals">Pipelines and Categoricals</a></h2>
 
  </header>
  <footer class="post-info">
    <abbr class="published" title="2016-01-04T00:00:00-06:00">
      Mon 04 January 2016
    </abbr>
    <address class="vcard author">
      By           <a class="url fn" href="./author/tom-augspurger.html">Tom Augspurger</a>
    </address>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p>My favorite feature of scikit-learn is its pipelines.
These are a nice convenience for putting together a chain
of operations from raw data to classifier.
More importantly, they help prevent training data
from leaking into your validation, so I use them whenever possible.</p>
<p>Pandas somewhat recently added a <a href="http://pandas.pydata.org/pandas-docs/version/0.17.1/categorical.html"><code>Categorical</code></a> dtype (<em>factors</em> if you're
coming from R-land).
These are great for representing data (often non-numeric) that comes from
a <em>fixed, discrete</em> set of possibly ordered categories.</p>
<p>I frequently see questions on how to use <code>Categoricals</code> with
scikit-learn. I sat down today to write a quick post on <em>a</em> way to
accomplish this.</p>
<p>This post grew to be a bit longer than I intended so I'm assuming some familiarity with</p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Dummy_variable_(statistics)">dummy variables</a></li>
<li>Pandas Categoricals (<code>codes</code> vs. <code>categories</code>)</li>
<li>Scikit-learn Estimator API</li>
<li>Scikit-learn Pipelines</li>
</ol>
<h2>The Data</h2>
<p>We'll use the ggplot2 builtin <code>diamonds</code> dataset (via
<a href="https://twitter.com/VincentAB">Vincent Arel-Bundock</a>'s great
<a href="https://github.com/vincentarelbundock/Rdatasets"><code>Rdatasets</code></a> repository)</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="n">url</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;https://github.com/vincentarelbundock/Rdatasets/raw/master/&#39;</span>
       <span class="s1">&#39;csv/ggplot2/diamonds.csv&#39;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>


<table border="0" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>carat</th>      <th>cut</th>      <th>color</th>      <th>clarity</th>      <th>depth</th>      <th>table</th>      <th>price</th>      <th>x</th>      <th>y</th>      <th>z</th>    </tr>  </thead>  <tbody>    <tr>      <th>1</th>      <td>0.23</td>      <td>Ideal</td>      <td>E</td>      <td>SI2</td>      <td>61.5</td>      <td>55</td>      <td>326</td>      <td>3.95</td>      <td>3.98</td>      <td>2.43</td>    </tr>    <tr>      <th>2</th>      <td>0.21</td>      <td>Premium</td>      <td>E</td>      <td>SI1</td>      <td>59.8</td>      <td>61</td>      <td>326</td>      <td>3.89</td>      <td>3.84</td>      <td>2.31</td>    </tr>    <tr>      <th>3</th>      <td>0.23</td>      <td>Good</td>      <td>E</td>      <td>VS1</td>      <td>56.9</td>      <td>65</td>      <td>327</td>      <td>4.05</td>      <td>4.07</td>      <td>2.31</td>    </tr>    <tr>      <th>4</th>      <td>0.29</td>      <td>Premium</td>      <td>I</td>      <td>VS2</td>      <td>62.4</td>      <td>58</td>      <td>334</td>      <td>4.20</td>      <td>4.23</td>      <td>2.63</td>    </tr>    <tr>      <th>5</th>      <td>0.31</td>      <td>Good</td>      <td>J</td>      <td>SI2</td>      <td>63.3</td>      <td>58</td>      <td>335</td>      <td>4.34</td>      <td>4.35</td>      <td>2.75</td>    </tr>  </tbody></table>

<h2>Preprocessing</h2>
<p>I'm going to assume here that you know your categories ahead of time.</p>
<div class="codehilite"><pre><span></span><span class="n">cat_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;cut&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;clarity&#39;</span><span class="p">]</span>
<span class="n">cuts</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Fair&#39;</span><span class="p">,</span> <span class="s1">&#39;Good&#39;</span><span class="p">,</span> <span class="s1">&#39;Very Good&#39;</span><span class="p">,</span> <span class="s1">&#39;Premium&#39;</span><span class="p">,</span> <span class="s1">&#39;Ideal&#39;</span><span class="p">]</span>
<span class="n">color</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s2">&quot;DEFGHIJ&quot;</span><span class="p">)</span>
<span class="n">clarity</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;I1&quot;</span><span class="p">,</span> <span class="s2">&quot;SI2&quot;</span><span class="p">,</span> <span class="s2">&quot;SI1&quot;</span><span class="p">,</span> <span class="s2">&quot;VS2&quot;</span><span class="p">,</span> <span class="s2">&quot;VS1&quot;</span><span class="p">,</span> <span class="s2">&quot;VVS2&quot;</span><span class="p">,</span> <span class="s2">&quot;VVS1&quot;</span><span class="p">,</span> <span class="s2">&quot;IF&quot;</span><span class="p">]</span>
</pre></div>


<p>And we'll use the <code>Categorical</code> constructor to convert the strings
to categoricals.
I'm not a gemologist, but I didn't make the <code>color</code> field ordered.
It doesn't matter for our classifier either way, and we get to see a
bit of variety in the code.</p>
<div class="codehilite"><pre><span></span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;cut&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">cut</span><span class="p">,</span> <span class="n">categories</span><span class="o">=</span><span class="n">cuts</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">color</span><span class="p">,</span> <span class="n">categories</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;clarity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">clarity</span><span class="p">,</span> <span class="n">categories</span><span class="o">=</span><span class="n">clarity</span><span class="p">,</span>
                               <span class="n">ordered</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
</pre></div>


<div class="codehilite"><pre><span></span>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
Int64Index: 53940 entries, 1 to 53940
Data columns (total 10 columns):
carat      53940 non-null float64
cut        53940 non-null object
color      53940 non-null object
clarity    53940 non-null object
depth      53940 non-null float64
table      53940 non-null float64
price      53940 non-null int64
x          53940 non-null float64
y          53940 non-null float64
z          53940 non-null float64
dtypes: float64(6), int64(1), object(3)
memory usage: 4.5+ MB
</pre></div>


<h2>The Transformer</h2>
<p>Our pipeline will be pretty basic, just enough to motivate
writing a proper transformer.
We'll fit a <a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Lasso.html">Lasso</a>, which means we should probably <a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html">scale</a> our features
before fitting.
So our pipeline will be</p>
<ol>
<li>raw data</li>
<li>dummy variables / OneHotEncoded</li>
<li>Scaled</li>
<li>Lasso</li>
</ol>
<p>Our imports</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>

<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Lasso</span>
<span class="kn">import</span> <span class="nn">sklearn.cross_validation</span> <span class="kn">as</span> <span class="nn">cv</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">make_pipeline</span><span class="p">,</span> <span class="n">TransformerMixin</span>
</pre></div>


<p>We're predicting price, so let's drop that from the
exogenous variables.
And we'll throw in a train-test split for fun.</p>
<div class="codehilite"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span>

<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">train_test_split</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">y</span>
<span class="p">)</span>
</pre></div>


<p>And now for the transformer itself.
I encourage you to skim the implementation; I highlight
the interesting sections later on.</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">CategoricalTransformer</span><span class="p">(</span><span class="n">TransformerMixin</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns_</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cat_columns_</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;category&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_cat_columns_</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cat_columns_</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cat_map_</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="n">X</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span>
                         <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_columns_</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ordered_</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="n">X</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">ordered</span>
                         <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_columns_</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dummy_columns_</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">col</span><span class="p">,</span> <span class="n">v</span><span class="p">])</span>
                                     <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_map_</span><span class="p">[</span><span class="n">col</span><span class="p">]]</span>
                               <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_columns_</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transformed_columns_</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">non_cat_columns_</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dummy_columns_</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                                     <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_columns_</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                  <span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transformed_columns_</span><span class="p">)</span>
                  <span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">series</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">non_cat_cols</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformed_columns_</span>
                            <span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_cat_columns_</span><span class="p">))</span>
        <span class="n">non_cat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">non_cat_cols</span><span class="p">],</span>
                               <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">non_cat_columns_</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">cat_cols</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dummy_columns_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_columns_</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">cat_cols</span><span class="p">)</span>
            <span class="n">codes</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">locs</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">cats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="o">.</span><span class="n">from_codes</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_map_</span><span class="p">[</span><span class="n">col</span><span class="p">],</span>
                                             <span class="n">ordered</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ordered_</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
            <span class="n">series</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">cats</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">col</span><span class="p">))</span>
        <span class="c1"># concats sorts, we want the original order</span>
        <span class="n">df</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">non_cat</span><span class="p">]</span> <span class="o">+</span> <span class="n">series</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns_</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">df</span>

<span class="bp">self</span> <span class="o">=</span> <span class="n">CategoricalTransformer</span><span class="p">()</span>  <span class="c1"># for testing later</span>
</pre></div>


<p>Well, that's quite a bit of code.
First, some higher-level thoughts.</p>
<p>This is <em>much</em> more code than necessary for just exploring things.
You could get away with something like</p>
<div class="codehilite"><pre><span></span><span class="n">X_train_</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">X_train</span><span class="p">))</span>
<span class="n">lm</span> <span class="o">=</span> <span class="n">Lasso</span><span class="p">()</span>
<span class="n">lm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</pre></div>


<p>Most of the extra code up there is dealing with things that will come
up when you go to actually use the estimator in production.
Things like rows being in a different order or training samples not seeing
every code.
Between pandas Categoricals and all of the bookkeeping in the <code>.fit</code> method,
we can handle these cases.</p>
<h2>In Detail</h2>
<p>First, notice that we don't have an <code>__init__</code> method.
You could easily include one, and explicitly assign your categories here.
I think that's how scikit-learn's <code>OneHotEncoder</code> does it.
We'll rely on that information being stored in the DataFrame.</p>
<h2>In Detail: <code>fit</code></h2>
<p>The <code>fit</code> step really is just bookkeeping about how to go from labels
(in pandas-land) to positions (in NumPy land).</p>
<p>The most interesting thing is the underused <a href="http://pandas.pydata.org/pandas-docs/version/0.17.1/generated/pandas.DataFrame.select_dtypes.html"><code>select_dtypes</code></a> method,
but that's doesn't have much to do with our task at hand.
The main takeaway from <code>.fit</code> is that we can reliably</p>
<ol>
<li>transform a DataFrame to a dummy encoded feature Matrix</li>
<li>invert that transformation back to a DataFrame (with our categories intact)</li>
</ol>
<p>And to repeat, those transformations will work regardless of the ordering
of the features in our training dataset.
We don't even need all of the categories to actually be realized.</p>
<h2>In Detail: <code>transform</code></h2>
<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
              <span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transformed_columns_</span><span class="p">)</span>
              <span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</pre></div>


<p>The <code>transform</code> method uses the <code>get_dummies</code> function from pandas to go from
our categories to a dummy-variable representation. By default
it only operates on <code>categorical</code> or <code>object</code> dtypes, appending the dummy
variables as new columns on the end of the DataFrame, while dropping the
categorical column.
The column names are the original column name joined with the actual category
by an underscore.
We <code>.reindex</code> by <code>self.transformed_columns_</code> in case a specific category
was not realized in the training dataset we fit on (say <code>color_I</code> just didn't
have any observations)</p>
<div class="codehilite"><pre><span></span><span class="o">&gt;&gt;&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">transformed_columns_</span>
<span class="n">Index</span><span class="p">([</span><span class="s1">&#39;carat&#39;</span><span class="p">,</span> <span class="s1">&#39;depth&#39;</span><span class="p">,</span> <span class="s1">&#39;table&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;cut_Fair&#39;</span><span class="p">,</span> <span class="s1">&#39;cut_Good&#39;</span><span class="p">,</span>
       <span class="s1">&#39;cut_Very Good&#39;</span><span class="p">,</span> <span class="s1">&#39;cut_Premium&#39;</span><span class="p">,</span> <span class="s1">&#39;cut_Ideal&#39;</span><span class="p">,</span> <span class="s1">&#39;color_D&#39;</span><span class="p">,</span> <span class="s1">&#39;color_E&#39;</span><span class="p">,</span>
       <span class="s1">&#39;color_F&#39;</span><span class="p">,</span> <span class="s1">&#39;color_G&#39;</span><span class="p">,</span> <span class="s1">&#39;color_H&#39;</span><span class="p">,</span> <span class="s1">&#39;color_I&#39;</span><span class="p">,</span> <span class="s1">&#39;color_J&#39;</span><span class="p">,</span> <span class="s1">&#39;clarity_I1&#39;</span><span class="p">,</span>
       <span class="s1">&#39;clarity_SI2&#39;</span><span class="p">,</span> <span class="s1">&#39;clarity_SI1&#39;</span><span class="p">,</span> <span class="s1">&#39;clarity_VS2&#39;</span><span class="p">,</span> <span class="s1">&#39;clarity_VS1&#39;</span><span class="p">,</span>
       <span class="s1">&#39;clarity_VVS2&#39;</span><span class="p">,</span> <span class="s1">&#39;clarity_VVS1&#39;</span><span class="p">,</span> <span class="s1">&#39;clarity_IF&#39;</span><span class="p">],</span>
      <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;object&#39;</span><span class="p">)</span>
</pre></div>


<p>This is our feature matrix, that will be fed to the next stage of the pipeline.</p>
<h2>In Detail: <code>inverse_transform</code></h2>
<p>The <code>inverse_transform</code> method isn't used as often, but is nice to have around.
We use our mappings from NumPy positions back to pandas labels to reconstruct
our arrays.</p>
<p>There are two methods worth pointing out</p>
<ul>
<li><a href="http://pandas.pydata.org/pandas-docs/version/0.17.1/generated/pandas.Index.get_indexer.html"><code>pandas.Index.get_indexer</code></a></li>
</ul>
<p>This is a lower level method for getting the index <em>positions</em> when you have
an array of <em>labels</em>. We use this since we need to know where the label for,
say, <code>caret</code> ended up in the transformed NumPy array.</p>
<ul>
<li><a href="http://pandas.pydata.org/pandas-docs/version/0.17.1/generated/pandas.Categorical.from_codes.html"><code>pandas.Categorical.from_codes</code></a></li>
</ul>
<p>This is an alternative constructor to the usual.
It's the method you want when you've got a set of <code>codes</code> (integers)
and want to construct a <code>Categorical</code>.</p>
<p>Pandas will <a href="https://github.com/pydata/pandas/issues/8745">someday</a>
add a <code>from_dummies</code> or <code>invert_dummies</code> (and we'll do it quicker if you ask
for it, and even more quickly if you implement it), but for now we write our own.</p>
<p>The trick is to recognize that once we've dummy encoded the values, a row's
<code>argmax</code> represents the position of the category. For example, if we look at <code>cut</code></p>
<div class="codehilite"><pre><span></span>self.transform(X)[self.dummy_columns_[&#39;cut&#39;]].head()
</pre></div>


<table border="0" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>cut_Fair</th>      <th>cut_Good</th>      <th>cut_Very Good</th>      <th>cut_Premium</th>      <th>cut_Ideal</th>    </tr>  </thead>  <tbody>    <tr>      <th>1</th>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>2</th>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>3</th>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>4</th>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>5</th>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>  </tbody></table>

<p>We see that the <code>argmax</code> for the first row is <code>4</code>.</p>
<p>In this section:</p>
<div class="codehilite"><pre><span></span><span class="n">locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_columns_</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">cat_cols</span><span class="p">)</span>
<span class="n">codes</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">locs</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">cats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="o">.</span><span class="n">from_codes</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_map_</span><span class="p">[</span><span class="n">col</span><span class="p">],</span>
                                 <span class="n">ordered</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ordered_</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
</pre></div>


<p><code>codes</code>, the <code>argmax</code> for each row, is an array of integers.
We use those codes along with our original categories and ordering
to reconstruct the original Categorical.</p>
<p>The rest is some more handling of non-categorical columns, concatination,
and column sorting.</p>
<h2>Check your work</h2>
<p>Pandas has a bunch of useful methods for testing.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">pandas.util.testing</span> <span class="kn">as</span> <span class="nn">tm</span>

<span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">index</span>

<span class="n">tm</span><span class="o">.</span><span class="n">assert_frame_equal</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
</pre></div>


<p>No <code>AssertionError</code> is good news :)</p>
<h2>Use it</h2>
<p>And lets "deploy" it to "production"</p>
<div class="codehilite"><pre><span></span><span class="n">pipe</span> <span class="o">=</span> <span class="n">make_pipeline</span><span class="p">(</span><span class="n">CategoricalTransformer</span><span class="p">(),</span> <span class="n">StandardScaler</span><span class="p">(),</span> <span class="n">Lasso</span><span class="p">())</span>

<span class="n">pipe</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s2">&quot;train&quot;</span><span class="p">,</span> <span class="n">pipe</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="n">pipe</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">))</span>
</pre></div>


<p>outputs</p>
<div class="codehilite"><pre><span></span>train 0.92170189249
test 0.914089736447
</pre></div>


<p>If you care about things like multicolinearity you'd want to either drop
the intercept or drop one of the categories per <code>Categorical</code>.</p>
<h2>Soap Box</h2>
<p>In an ideal world, writing your own transformer here wouldn't be necessary
(technically you don't have to write it yourself, just take my code).
But we don't live in an ideal world.
Scikit-learn uses the NumPy array as its fundamental data type.
Pandas has recently introduced several dtypes on our own, instead of
at the NumPy level.
There are some <a href="https://github.com/pydata/pandas/issues/8350">very interesting</a>
conversations on why pandas went this route.
Whether or not that's the right path (I think it was, but hey) is mostly academic.
The real-world consequence is that pandas has developed dialects that many other PyData-ecosystem projects don't understand.</p>
<p><a href="https://twitter.com/t3kcit">Andreas Mueller</a>, a core developer for scikit-learn,
has said he wants to explore this space a bit more this year, so hopefully things
will get better.
I'm looking forward to seeing where it goes, and how we can help.</p>
  </div><!-- /.entry-content -->
</section>

    <footer>
      <p>&copy; Tom Augspurger </p>
    </footer>
  </main>

</body>
</html>