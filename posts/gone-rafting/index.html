<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Gone Rafting | Tom's Blog</title>
<meta name=keywords content><meta name=description content="Last week, I was fortunate to attend Dave Beazley&rsquo;s Rafting Trip course. The pretext of the course is to implement the Raft Consensus Algorithm.
I&rsquo;ll post more about Raft, and the journey of implementing, it later. But in brief, Raft is an algorithm that lets a cluster of machines work together to reliably do something. If you had a service that needed to stay up (and stay consistent), even if some of the machines in the cluster went down, then you might want to use Raft."><meta name=author content><link rel=canonical href=https://tomaugspurger.net/posts/gone-rafting/><link crossorigin=anonymous href=/assets/css/stylesheet.ced21e6d3497ee93fed8f8b357448095840179bd510b5ea0e6013078712e6dd1.css integrity="sha256-ztIebTSX7pP+2PizV0SAlYQBeb1RC16g5gEweHEubdE=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://tomaugspurger.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tomaugspurger.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tomaugspurger.net/favicon-32x32.png><link rel=apple-touch-icon href=https://tomaugspurger.net/apple-touch-icon.png><link rel=mask-icon href=https://tomaugspurger.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tomaugspurger.net/posts/gone-rafting/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Gone Rafting"><meta property="og:description" content="Last week, I was fortunate to attend Dave Beazley&rsquo;s Rafting Trip course. The pretext of the course is to implement the Raft Consensus Algorithm.
I&rsquo;ll post more about Raft, and the journey of implementing, it later. But in brief, Raft is an algorithm that lets a cluster of machines work together to reliably do something. If you had a service that needed to stay up (and stay consistent), even if some of the machines in the cluster went down, then you might want to use Raft."><meta property="og:type" content="article"><meta property="og:url" content="https://tomaugspurger.net/posts/gone-rafting/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-13T14:30:19-05:00"><meta property="article:modified_time" content="2023-08-13T14:30:19-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Gone Rafting"><meta name=twitter:description content="Last week, I was fortunate to attend Dave Beazley&rsquo;s Rafting Trip course. The pretext of the course is to implement the Raft Consensus Algorithm.
I&rsquo;ll post more about Raft, and the journey of implementing, it later. But in brief, Raft is an algorithm that lets a cluster of machines work together to reliably do something. If you had a service that needed to stay up (and stay consistent), even if some of the machines in the cluster went down, then you might want to use Raft."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tomaugspurger.net/posts/"},{"@type":"ListItem","position":2,"name":"Gone Rafting","item":"https://tomaugspurger.net/posts/gone-rafting/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Gone Rafting","name":"Gone Rafting","description":"Last week, I was fortunate to attend Dave Beazley\u0026rsquo;s Rafting Trip course. The pretext of the course is to implement the Raft Consensus Algorithm.\nI\u0026rsquo;ll post more about Raft, and the journey of implementing, it later. But in brief, Raft is an algorithm that lets a cluster of machines work together to reliably do something. If you had a service that needed to stay up (and stay consistent), even if some of the machines in the cluster went down, then you might want to use Raft.","keywords":[],"articleBody":"Last week, I was fortunate to attend Dave Beazley’s Rafting Trip course. The pretext of the course is to implement the Raft Consensus Algorithm.\nI’ll post more about Raft, and the journey of implementing, it later. But in brief, Raft is an algorithm that lets a cluster of machines work together to reliably do something. If you had a service that needed to stay up (and stay consistent), even if some of the machines in the cluster went down, then you might want to use Raft.\nRaft achieves this consensus and availability through log replication. A single node of the cluster is elected as the Leader, and all other nodes are Followers. The Leader interacts with clients to accept new commands (set x=41, or get y). The Leader notes these commands in its logs and sends them to the other nodes in the cluster. Once the logs have been replicated to a majority of the nodes in a cluster, the Leader can apply the command (actually doing it) and respond to the client. That’s the “normal operation” mode of Raft. Beyond that, much of the complexity of Raft comes from handling all the edge cases (what if a leader crashes? What if the leader comes back? What if there’s a network partition and two nodes try to become leader? and on, and on)\nRaft was just about perfect for a week-long course. It’s a complex enough problem to challenge just about anyone. But it’s not so big that a person can’t hope to implement (much of) it in a week.\nI liked the structure of the course itself. The actual “lecture” time was pretty short. We’d typically start the day with a short overview of one component of the problem. But after that, we spent a majority of the time actually working on the project. Dave didn’t just throw us to the wolves, but there was many a reference to “Draw the rest of the owl”.\nThat said, I really benefited from Dave’s gentle nudges on which part of the puzzle to work on next. The design space of implementing Raft is incredibly large. A typical Raft implementation will need to handle, at a minimum:\nCommunicating between multiple machines Handling events (messages over the network, timers to call elections, etc.) Leader elections The Log Log replication Achieving consensus The State Machine (e.g. updating the Key Value store) Client interaction (a surprisingly tricky part, that completely blew up my implementation) Persistence You can implement these in just about any order. Going into the class I had no idea which would be “best” to do first (I still don’t think there’s a right order, but focusing on the Log and Log replication does seem like as good a start as any).\nAnd that’s just the order you do things in. There’s also the question of how you go about implementing it. Are you using threads and queues, or asyncio? Mutable or immutable data structures? How do you test and monitor this?\nBut I think the biggest decision is around how you actually architect the system. How do you break this large problem down into smaller components? And how do those components interact? That’s the kind of thinking that’s helpful in my day job, and this project really taught me a lot (specifically, that I still have a ton to learn about designing and implementing this type of system). Also, it reinforced how difficult distributed systems can be.\nOur class was in-person (Dave’s last course in this specific office). While I missed my big monitor and fancy ergonomic keyboard of my home-office, (not to mention my family), I am glad I got to go in person. It was nice to just let out an exasperated sigh and chat with classmate about how they’re handling a particularly tricky part of the project. The loved the informal conversations at breakfast and lunch (which inevitably turned back to aft).\nI want to clean up a few parts of my implementation (AKA, trash the whole thing and start over). Once done I’ll make a followup post.\nThanks to Dave for hosting a great course, the other classmates, and to my family for letting me ditch them to go type on a laptop for a week.\n","wordCount":"708","inLanguage":"en","datePublished":"2023-08-13T14:30:19-05:00","dateModified":"2023-08-13T14:30:19-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://tomaugspurger.net/posts/gone-rafting/"},"publisher":{"@type":"Organization","name":"Tom's Blog","logo":{"@type":"ImageObject","url":"https://tomaugspurger.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tomaugspurger.net/ accesskey=h title="Tom's Blog (Alt + H)">Tom's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://tomaugspurger.net/about/ title=About><span>About</span></a></li><li><a href=https://tomaugspurger.net/archives title=Archive><span>Archive</span></a></li><li><a href=https://tomaugspurger.net/index.xml title=RSS><span>RSS</span></a></li><li><a href=https://tomaugspurger.net/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Gone Rafting</h1><div class=post-meta><span title='2023-08-13 14:30:19 -0500 -0500'>August 13, 2023</span></div></header><div class=post-content><p>Last week, I was fortunate to attend Dave Beazley&rsquo;s <a href=https://dabeaz.com/raft.html>Rafting
Trip</a> course. The pretext of the course is to
implement the <a href=https://raft.github.io/>Raft Consensus Algorithm</a>.</p><p>I&rsquo;ll post more about Raft, and the journey of implementing, it later. But in
brief, Raft is an algorithm that lets a cluster of machines work together to
<em>reliably</em> do something. If you had a service that needed to stay up (and stay
consistent), even if some of the machines in the cluster went down, then you
might want to use Raft.</p><p>Raft achieves this consensus and availability through <em>log replication</em>. A
single node of the cluster is elected as the Leader, and all other nodes are
Followers. The Leader interacts with clients to accept new commands (<code>set x=41</code>,
or <code>get y</code>). The Leader notes these commands in its logs and sends them to the
other nodes in the cluster. Once the logs have been replicated to a majority of
the nodes in a cluster, the Leader can <em>apply</em> the command (actually doing it)
and respond to the client. That&rsquo;s the &ldquo;normal operation&rdquo; mode of Raft. Beyond
that, much of the complexity of Raft comes from handling all the edge cases
(what if a leader crashes? What if the leader comes back? What if there&rsquo;s a
network partition and two nodes try to become leader? and on, and on)</p><p>Raft was just about perfect for a week-long course. It&rsquo;s a complex enough
problem to challenge just about anyone. But it&rsquo;s not <em>so</em> big that a person
can&rsquo;t hope to implement (much of) it in a week.</p><p>I liked the structure of the course itself. The actual &ldquo;lecture&rdquo; time was pretty
short. We&rsquo;d typically start the day with a short overview of one component of
the problem. But after that, we spent a majority of the time actually working on
the project. Dave didn&rsquo;t just throw us to the wolves, but there was many a
reference to <a href=https://knowyourmeme.com/memes/how-to-draw-an-owl>&ldquo;Draw the rest of the
owl&rdquo;</a>.</p><p>That said, I <em>really</em> benefited from Dave&rsquo;s gentle nudges on which part of the
puzzle to work on next. The design space of implementing Raft is incredibly large.
A typical Raft implementation will need to handle, at a minimum:</p><ol><li>Communicating between multiple machines</li><li>Handling events (messages over the network, timers to call elections, etc.)</li><li>Leader elections</li><li>The Log</li><li>Log replication</li><li>Achieving consensus</li><li>The State Machine (e.g. updating the Key Value store)</li><li>Client interaction (a surprisingly tricky part, that completely blew up my
implementation)</li><li>Persistence</li></ol><p>You can implement these in just about any order. Going into the class I had no
idea which would be &ldquo;best&rdquo; to do first (I still don&rsquo;t think there&rsquo;s a right
order, but focusing on the Log and Log replication does seem like as good a
start as any).</p><p>And that&rsquo;s just the <em>order</em> you do things in. There&rsquo;s also the question of <em>how</em>
you go about implementing it. Are you using threads and queues, or asyncio?
Mutable or immutable data structures? How do you test and monitor this?</p><p>But I think the biggest decision is around how you actually architect the
system. How do you break this large problem down into smaller components? And
how do those components interact? <em>That&rsquo;s</em> the kind of thinking that&rsquo;s helpful
in my day job, and this project really taught me a lot (specifically, that I
still have a ton to learn about designing and implementing this type of system).
Also, it reinforced how difficult distributed systems can be.</p><p>Our class was in-person (Dave&rsquo;s last course in this specific office). While I
missed my big monitor and fancy ergonomic keyboard of my home-office, (not to
mention my family), I am glad I got to go in person. It was nice to just let out
an exasperated sigh and chat with classmate about how they&rsquo;re handling a
particularly tricky part of the project. The loved the informal conversations at
breakfast and lunch (which inevitably turned back to aft).</p><p>I want to clean up a few parts of my implementation (AKA, trash the whole thing
and start over). Once done I&rsquo;ll make a followup post.</p><p>Thanks to Dave for hosting a great course, the other classmates, and to my
family for letting me ditch them to go type on a laptop for a week.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://tomaugspurger.net/>Tom's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><a rel=me href=https://mastodon.social/@TomAugspurger></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>