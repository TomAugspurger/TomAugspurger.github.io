<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Serializing Dataclasses | Tom's Blog</title>
<meta name=keywords content><meta name=description content="This post is a bit of a tutorial on serializing and deserializing Python
dataclasses.  I&rsquo;ve been hacking on zarr-python-v3 a bit, which uses some
dataclasses to represent some metadata objects. Those objects need to be
serialized to and deserialized from JSON.
This is a (surprisingly?) challenging area, and there are several excellent
libraries out there that you should probably use. My personal favorite is
msgspec, but cattrs, pydantic, and pyserde are also options. But
hopefully this can be helpful for understanding how those libraries work at a
conceptual level (their exact implementations will look very different.) In
zarr-python&rsquo;s case, this didn&rsquo;t quite warrant needing to bring in a
dependency, so we rolled our own."><meta name=author content><link rel=canonical href=https://tomaugspurger.net/posts/serializing-dataclasses/><link crossorigin=anonymous href=/assets/css/stylesheet.ced21e6d3497ee93fed8f8b357448095840179bd510b5ea0e6013078712e6dd1.css integrity="sha256-ztIebTSX7pP+2PizV0SAlYQBeb1RC16g5gEweHEubdE=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://tomaugspurger.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tomaugspurger.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tomaugspurger.net/favicon-32x32.png><link rel=apple-touch-icon href=https://tomaugspurger.net/apple-touch-icon.png><link rel=mask-icon href=https://tomaugspurger.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tomaugspurger.net/posts/serializing-dataclasses/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Serializing Dataclasses"><meta property="og:description" content="This post is a bit of a tutorial on serializing and deserializing Python
dataclasses.  I&rsquo;ve been hacking on zarr-python-v3 a bit, which uses some
dataclasses to represent some metadata objects. Those objects need to be
serialized to and deserialized from JSON.
This is a (surprisingly?) challenging area, and there are several excellent
libraries out there that you should probably use. My personal favorite is
msgspec, but cattrs, pydantic, and pyserde are also options. But
hopefully this can be helpful for understanding how those libraries work at a
conceptual level (their exact implementations will look very different.) In
zarr-python&rsquo;s case, this didn&rsquo;t quite warrant needing to bring in a
dependency, so we rolled our own."><meta property="og:type" content="article"><meta property="og:url" content="https://tomaugspurger.net/posts/serializing-dataclasses/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-31T12:00:00-05:00"><meta property="article:modified_time" content="2024-08-31T12:00:00-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Serializing Dataclasses"><meta name=twitter:description content="This post is a bit of a tutorial on serializing and deserializing Python
dataclasses.  I&rsquo;ve been hacking on zarr-python-v3 a bit, which uses some
dataclasses to represent some metadata objects. Those objects need to be
serialized to and deserialized from JSON.
This is a (surprisingly?) challenging area, and there are several excellent
libraries out there that you should probably use. My personal favorite is
msgspec, but cattrs, pydantic, and pyserde are also options. But
hopefully this can be helpful for understanding how those libraries work at a
conceptual level (their exact implementations will look very different.) In
zarr-python&rsquo;s case, this didn&rsquo;t quite warrant needing to bring in a
dependency, so we rolled our own."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tomaugspurger.net/posts/"},{"@type":"ListItem","position":2,"name":"Serializing Dataclasses","item":"https://tomaugspurger.net/posts/serializing-dataclasses/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Serializing Dataclasses","name":"Serializing Dataclasses","description":"This post is a bit of a tutorial on serializing and deserializing Python dataclasses. I\u0026rsquo;ve been hacking on zarr-python-v3 a bit, which uses some dataclasses to represent some metadata objects. Those objects need to be serialized to and deserialized from JSON.\nThis is a (surprisingly?) challenging area, and there are several excellent libraries out there that you should probably use. My personal favorite is msgspec, but cattrs, pydantic, and pyserde are also options. But hopefully this can be helpful for understanding how those libraries work at a conceptual level (their exact implementations will look very different.) In zarr-python\u0026rsquo;s case, this didn\u0026rsquo;t quite warrant needing to bring in a dependency, so we rolled our own.\n","keywords":[],"articleBody":"This post is a bit of a tutorial on serializing and deserializing Python dataclasses. I’ve been hacking on zarr-python-v3 a bit, which uses some dataclasses to represent some metadata objects. Those objects need to be serialized to and deserialized from JSON.\nThis is a (surprisingly?) challenging area, and there are several excellent libraries out there that you should probably use. My personal favorite is msgspec, but cattrs, pydantic, and pyserde are also options. But hopefully this can be helpful for understanding how those libraries work at a conceptual level (their exact implementations will look very different.) In zarr-python’s case, this didn’t quite warrant needing to bring in a dependency, so we rolled our own.\nLike msgspec and cattrs, I like to have serialization logic separate from the core metadata logic. Ideally, you don’t need to pollute your object models with serialization methods, and don’t need to shoehorn your business logic to fit the needs of serialization (too much). And ideally the actual validation is done at the boundaries of your program, where you’re actually converting from the unstructured JSON to your structured models. Internal to your program, you have static type checking to ensure you’re passing around the appropriate types.\nThis is my first time diving into these topics, so if you spot anything that’s confusing or plain wrong, then let me know.\nOverview At a high level, we want a pair of methods that can serialize some dataclass instance into a format like JSON and deserialize that output back into the original dataclass.\nThe main challenge during serialization is encountering fields that Python’s json module doesn’t natively support. This might be “complex” objects like Python datetimes or NumPy dtype objects. Or it could be instances of other dataclasses if you have some nested data structure.\nWhen deserializing, there are lots of pitfalls to avoid, but our main goal is to support typed deserialization. Any time we converted a value (like a datetime to a string, or a dataclass to a dict), we’ll need to undo that conversion into the proper type.\nExample To help make things clearer, we’ll work with this example:\n@dataclasses.dataclass class ArrayMetadata: shape: tuple[int, ...] timestamp: datetime.datetime # note 1 @dataclasses.dataclass class EncoderA: value: int @dataclasses.dataclass class EncoderB: value: int @dataclasses.dataclass class Metadata: version: typing.Literal[\"3\"] # note 2 array_metadata: ArrayMetadata # note 2 encoder: EncoderA | EncoderB # note 4 attributes: dict[str, typing.Any] name: str | None = None # note 5 Successfully serializing an instance of Metadata requires working through a few things:\nPython datetimes are not natively serializable by Python’s JSON encoder. version is a Literal[\"3\"], in other words \"3\" is only valid value there. We’d ideally validate that when deserializing Metadata (since we can’t rely on a static linter like mypy to validate JSON data read from a file). Metadata.array_metadata is a nested dataclass. We’ll need to recursively apply any special serialization / deserialization logic to any dataclasses we encounter Metadata.encoder is a union type, between EncoderA and EncoderB. We’ll need to ensure that the serialized version has enough information to deserialize this into the correct variant of that Union name is an Optional[str]. This is similar to a Union between two concrete types, where one of the types happens to be None. Serialization Serialization is relatively easy compared to deserialization. Given an instance of Metadata, we’ll use dataclasses.asdict to convert the dataclass to a dictionary of strings to values. The main challenge is telling the JSON encoder how to serialize each of those values, which might have be “complex” types (whether they be dataclasses or some builtin type like datetime.datetime). There are a few ways to do this, but the simplest way to do it is probably to use the default keyword of json.dumps.\ndef encode_value(x): if dataclasses.is_dataclass(x): return dataclasses.asdict(x) elif isinstance(x, datetime.datetime): return x.isoformat() # other special cases... return x If Python encounters a value it doesn’t know how to serialize, it will use your function.\n\u003e\u003e\u003e json.dumps({\"a\": datetime.datetime(2000, 1, 1)}, default=serialize) '{\"a\": \"2000-01-01T00:00:00\"}' For aesthetic reasons, we’ll use functools.singledispatch to write that:\nimport dataclasses, datetime, typing, json, functools @functools.singledispatch def encode_value(x: typing.Any) -\u003e typing.Any: if dataclasses.is_dataclass(x): return dataclasses.asdict(x) return x @encode_value.register(datetime.datetime) @encode_value.register(datetime.date) def _(x: datetime.date | datetime.datetime) -\u003e str: return x.isoformat() @encode_value.register(complex) def _(x: complex) -\u003e list[float, float]: return [x.real, x.imag] # more implementations for additional type... You’ll build up a list of supported types that your system can serialize.\nAnd define your serializer like so:\ndef serialize(x): return json.dumps(x, default=encode_value) and use it like:\n\u003e\u003e\u003e metadata = Metadata( ... version=\"3\", ... array_metadata=ArrayMetadata(shape=(2, 2), ... timestamp=datetime.datetime(2000, 1, 1)), ... encoder=EncoderA(value=1), ... attributes={\"foo\": \"bar\"} ... ) \u003e\u003e\u003e serialized = serialize(metadata) \u003e\u003e\u003e serialized '{\"version\": \"3\", \"array_metadata\": {\"shape\": [2, 2], \"timestamp\": \"2000-01-01T00:00:00\"}, \"encoder\": {\"value\": 1}, \"attributes\": {\"foo\": \"bar\"}, \"name\": null}' Deserialization We’ve done serialization, so we should be about halfway done, right? Ha! Because we’ve signed up for typed deserialization, which will let us faithfully round-trip some objects, we have more work to do.\nA plain “roundtrip” like json.loads only gets us part of the way there:\n\u003e\u003e\u003e json.loads(serialized) {'version': '3', 'array_metadata': {'shape': [2, 2], 'timestamp': '2000-01-01T00:00:00'}, 'encoder': {'value': 1}, 'attributes': {'foo': 'bar'}, 'name': None} We have plain dictionaries instead of instances of our dataclasses and the timestamp is still a string. In short, we need to decode all the values we encoded earlier. To do that, we need the user to give us a bit more information: We need to know the desired dataclass to deserialize into.\ndef deserialize(into: type[T], data: bytes) -\u003e T: ... Given some type T (which we’ll assume is a dataclass; we could do some things with type annotations to actually check that) like Metadata, we’ll build an instance using the deserialized data (with the properly decoded types!)\nUsers will call that like\n\u003e\u003e\u003e deserialize(into=Metadata, data=deserialized) Metadata(...) For a dataclass type like Metadata, we can get the types of all of its fields at runtime with typing.get_type_hints:\n\u003e\u003e\u003e typing.get_type_hints(Metadata) {'version': typing.Literal['3'], 'array_metadata': __main__.ArrayMetadata, 'encoder': __main__.EncoderA | __main__.EncoderB, 'attributes': dict[str, typing.Any], 'name': str | None} So we “just” need to write a decode_value function that mirrors our encode_value function from earlier.\ndef decode_value(into: type[T], value: Any) -\u003e T: # the default implementation just calls the constructor, like int(x) # In practice, you have to deal with a lot more details like # Any, Literal, etc. return into(value) @decode_value.register(datetime.datetime) @decode_value.register(datetime.date) def _(into, value): return into.fromisoformat(value) @decode_value.register(complex) def _(into, value): return into(*value) # ... additional implementations Unfortunately, “just” writing that decoder proved to be challenging (have I mentioned that you should be using msgspec for this yet?). Probably the biggest challenge was dealing with Union types. The msgspec docs cover this really well in its Tagged Unions section, but I’ll give a brief overview.\nLet’s take a look at the declaration of encoder again:\n@dataclasses.dataclass class EncoderA: value: int @dataclasses.dataclass class EncoderB: key: str value: int class Metadata: ... encoder: EncoderA | EncoderB Right now, we serialize that as something like this:\n{ \"encoder\": { \"value\": 1 } } With that, it’s impossible to choose between EncoderA and EncoderB without some heuristic like “pick the first one”, or “pick the first one that succeeds”. There’s just not enough information available to the decoder. The idea of a “tagged union” is to embed a bit more information in the serialized representation that lets the decoder know which to pick.\n{ \"encoder\": { \"value\": 1, \"type\": \"EncoderA\", } } Now when the decoder looks at the type hints it’ll see EncoderA | EncoderB as the options, and can pick EncoderA based on the type field in the serialized object. We have introduced a new complication, though: how do we get type in there in the first place?\nThere’s probably multiple ways, but I went with typing.Annotated. It’s not the most user-friendly, but it lets you put additional metadata on the type hints, which can be used for whatever you want. We’d require the user to specify the variants of the union types as something like\nclass Tag: ... class EncoderA: value: int type: typing.Annotated[typing.Literal[\"a\"], Tag] = \"a\" class EncoderB: value: int key: str type: typing.Annotated[typing.Literal[\"b\"], Tag] = \"b\" (Other libraries might use something like the classes name as the value (by default) rather than requiring a single-valued Literal there.)\nNow we have a type key that’ll show up in the serialized form. When our decoder encounters a union of types to deserialize into, it can inspect their types hints with include_extras:\n\u003e\u003e\u003e typing.get_type_hints(EncoderA, include_extras=True) {'value': int, 'type': typing.Annotated[typing.Literal['a'], \u003cclass '__main__.Tag'\u003e]} By walking each of those pairs, the decoder can figure out which value in type maps to which dataclass type:\n\u003e\u003e\u003e tags_to_types { \"a\": EncoderA, \"b\": EncoderB, } Finally, given the object {\"type\": \"a\", \"value\": 1} it can pick the correct dataclass type to use. Then that can be fed through decode_value(EncoderA, value) to recursively decode all of its types properly.\nConclusion There’s much more to doing this well that I’ve skipped over in the name of simplicity (validation, nested types like list[Metadata] or tuples, good error messages, performance, extensibility, …). Once again, you should probably be using msgspec for this. But at least now you might have a bit of an idea how these libraries work and how type annotations can be used at runtime in Python.\n","wordCount":"1535","inLanguage":"en","datePublished":"2024-08-31T12:00:00-05:00","dateModified":"2024-08-31T12:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://tomaugspurger.net/posts/serializing-dataclasses/"},"publisher":{"@type":"Organization","name":"Tom's Blog","logo":{"@type":"ImageObject","url":"https://tomaugspurger.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tomaugspurger.net/ accesskey=h title="Tom's Blog (Alt + H)">Tom's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://tomaugspurger.net/about/ title=About><span>About</span></a></li><li><a href=https://tomaugspurger.net/archives title=Archive><span>Archive</span></a></li><li><a href=https://tomaugspurger.net/index.xml title=RSS><span>RSS</span></a></li><li><a href=https://tomaugspurger.net/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Serializing Dataclasses</h1><div class=post-meta><span title='2024-08-31 12:00:00 -0500 -0500'>August 31, 2024</span></div></header><div class=post-content><p>This post is a bit of a tutorial on serializing and deserializing Python
<a href=https://docs.python.org/3/library/dataclasses.html>dataclasses</a>. I&rsquo;ve been hacking on <a href=https://github.com/zarr-developers/zarr-python/>zarr-python-v3</a> a bit, which uses some
dataclasses to represent some metadata objects. Those objects need to be
serialized to and deserialized from JSON.</p><p>This is a (surprisingly?) challenging area, and there are several excellent
libraries out there that you should probably use. My personal favorite is
<a href=https://jcristharif.com/msgspec/>msgspec</a>, but <a href=https://catt.rs/en/stable/>cattrs</a>, <a href=https://docs.pydantic.dev/latest/>pydantic</a>, and <a href=https://yukinarit.github.io/pyserde/guide/en/>pyserde</a> are also options. But
hopefully this can be helpful for understanding how those libraries work at a
conceptual level (their exact implementations will look very different.) In
zarr-python&rsquo;s case, this didn&rsquo;t <em>quite</em> warrant needing to bring in a
dependency, so we rolled our own.</p><p>Like msgspec and cattrs, I like to have serialization logic separate from the
core metadata logic. Ideally, you don&rsquo;t need to pollute your object models with
serialization methods, and don&rsquo;t need to shoehorn your business logic to fit the
needs of serialization (too much). And ideally the actual validation is done at
the boundaries of your program, where you&rsquo;re actually converting from the
unstructured JSON to your structured models. Internal to your program, you have
static type checking to ensure you&rsquo;re passing around the appropriate types.</p><p>This is my first time diving into these topics, so if you spot anything that&rsquo;s
confusing or plain wrong, then <a href=https://mastodon.social/@TomAugspurger>let me know</a>.</p><h2 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h2><p>At a high level, we want a pair of methods that can serialize some dataclass
instance into a format like JSON and deserialize that output back into the
original dataclass.</p><p>The main challenge during serialization is encountering fields that Python&rsquo;s
<a href=https://docs.python.org/3/library/json.html>json</a> module doesn&rsquo;t natively support. This might be &ldquo;complex&rdquo; objects like
Python datetimes or NumPy dtype objects. Or it could be instances of other
dataclasses if you have some nested data structure.</p><p>When deserializing, there are <em>lots</em> of pitfalls to avoid, but our main goal is
to support <em>typed deserialization</em>. Any time we converted a value (like a
datetime to a string, or a dataclass to a dict), we&rsquo;ll need to undo that
conversion into the proper type.</p><h2 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h2><p>To help make things clearer, we&rsquo;ll work with this example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@dataclasses.dataclass</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ArrayMetadata</span>:
</span></span><span style=display:flex><span>    shape: tuple[int, <span style=color:#f92672>...</span>]
</span></span><span style=display:flex><span>    timestamp: datetime<span style=color:#f92672>.</span>datetime  <span style=color:#75715e># note 1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@dataclasses.dataclass</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EncoderA</span>:
</span></span><span style=display:flex><span>    value: int
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@dataclasses.dataclass</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EncoderB</span>:
</span></span><span style=display:flex><span>    value: int
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@dataclasses.dataclass</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Metadata</span>:
</span></span><span style=display:flex><span>    version: typing<span style=color:#f92672>.</span>Literal[<span style=color:#e6db74>&#34;3&#34;</span>]   <span style=color:#75715e># note 2</span>
</span></span><span style=display:flex><span>    array_metadata: ArrayMetadata  <span style=color:#75715e># note 2</span>
</span></span><span style=display:flex><span>    encoder: EncoderA <span style=color:#f92672>|</span> EncoderB   <span style=color:#75715e># note 4</span>
</span></span><span style=display:flex><span>    attributes: dict[str, typing<span style=color:#f92672>.</span>Any]
</span></span><span style=display:flex><span>    name: str <span style=color:#f92672>|</span> <span style=color:#66d9ef>None</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>     <span style=color:#75715e># note 5</span>
</span></span></code></pre></div><p>Successfully serializing an instance of <code>Metadata</code> requires working through a few things:</p><ol><li>Python datetimes are not natively serializable by Python&rsquo;s JSON encoder.</li><li><code>version</code> is a <code>Literal["3"]</code>, in other words <code>"3"</code> is only valid value there. We&rsquo;d ideally
validate that when deserializing <code>Metadata</code> (since we can&rsquo;t rely on a static linter like <code>mypy</code> to validate JSON data read from a file).</li><li><code>Metadata.array_metadata</code> is a nested dataclass. We&rsquo;ll need to recursively apply any special serialization / deserialization logic to any dataclasses we encounter</li><li><code>Metadata.encoder</code> is a union type, between <code>EncoderA</code> and <code>EncoderB</code>. We&rsquo;ll need to ensure that the serialized version has enough information to deserialize this into the correct variant of that Union</li><li><code>name</code> is an <code>Optional[str]</code>. This is similar to a Union between two concrete types, where one of the types happens to be None.</li></ol><h2 id=serialization>Serialization<a hidden class=anchor aria-hidden=true href=#serialization>#</a></h2><p>Serialization is <em>relatively</em> easy compared to deserialization. Given an
instance of <code>Metadata</code>, we&rsquo;ll use <code>dataclasses.asdict</code> to convert the dataclass
to a dictionary of strings to values. The main challenge is telling the JSON
encoder how to serialize each of those values, which might have be &ldquo;complex&rdquo;
types (whether they be dataclasses or some builtin type like
<code>datetime.datetime</code>). There are a few ways to do this, but the simplest way to
do it is probably to use the <code>default</code> keyword of <code>json.dumps</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>encode_value</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> dataclasses<span style=color:#f92672>.</span>is_dataclass(x):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dataclasses<span style=color:#f92672>.</span>asdict(x)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> isinstance(x, datetime<span style=color:#f92672>.</span>datetime):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> x<span style=color:#f92672>.</span>isoformat()
</span></span><span style=display:flex><span>    <span style=color:#75715e># other special cases... </span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x
</span></span></code></pre></div><p>If Python encounters a value it doesn&rsquo;t know how to serialize, it will use your function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> json<span style=color:#f92672>.</span>dumps({<span style=color:#e6db74>&#34;a&#34;</span>: datetime<span style=color:#f92672>.</span>datetime(<span style=color:#ae81ff>2000</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)}, default<span style=color:#f92672>=</span>serialize)
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39;{&#34;a&#34;: &#34;2000-01-01T00:00:00&#34;}&#39;</span>
</span></span></code></pre></div><p>For aesthetic reasons, we&rsquo;ll use <code>functools.singledispatch</code> to write that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> dataclasses<span style=color:#f92672>,</span> datetime<span style=color:#f92672>,</span> typing<span style=color:#f92672>,</span> json<span style=color:#f92672>,</span> functools
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@functools.singledispatch</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>encode_value</span>(x: typing<span style=color:#f92672>.</span>Any) <span style=color:#f92672>-&gt;</span> typing<span style=color:#f92672>.</span>Any:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> dataclasses<span style=color:#f92672>.</span>is_dataclass(x):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dataclasses<span style=color:#f92672>.</span>asdict(x)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@encode_value.register</span>(datetime<span style=color:#f92672>.</span>datetime)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@encode_value.register</span>(datetime<span style=color:#f92672>.</span>date)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_</span>(x: datetime<span style=color:#f92672>.</span>date <span style=color:#f92672>|</span> datetime<span style=color:#f92672>.</span>datetime) <span style=color:#f92672>-&gt;</span> str:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x<span style=color:#f92672>.</span>isoformat()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@encode_value.register</span>(complex)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_</span>(x: complex) <span style=color:#f92672>-&gt;</span> list[float, float]:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [x<span style=color:#f92672>.</span>real, x<span style=color:#f92672>.</span>imag]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># more implementations for additional type...</span>
</span></span></code></pre></div><p>You&rsquo;ll build up a list of <a href=https://jcristharif.com/msgspec/supported-types.html>supported types</a>
that your system can serialize.</p><p>And define your serializer like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>serialize</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> json<span style=color:#f92672>.</span>dumps(x, default<span style=color:#f92672>=</span>encode_value)
</span></span></code></pre></div><p>and use it like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> metadata <span style=color:#f92672>=</span> Metadata(
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     version<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;3&#34;</span>,
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     array_metadata<span style=color:#f92672>=</span>ArrayMetadata(shape<span style=color:#f92672>=</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>),
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     timestamp<span style=color:#f92672>=</span>datetime<span style=color:#f92672>.</span>datetime(<span style=color:#ae81ff>2000</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)),
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     encoder<span style=color:#f92672>=</span>EncoderA(value<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     attributes<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#34;foo&#34;</span>: <span style=color:#e6db74>&#34;bar&#34;</span>}
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> )
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> serialized <span style=color:#f92672>=</span> serialize(metadata)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> serialized
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39;{&#34;version&#34;: &#34;3&#34;, &#34;array_metadata&#34;: {&#34;shape&#34;: [2, 2], &#34;timestamp&#34;: &#34;2000-01-01T00:00:00&#34;}, &#34;encoder&#34;: {&#34;value&#34;: 1}, &#34;attributes&#34;: {&#34;foo&#34;: &#34;bar&#34;}, &#34;name&#34;: null}&#39;</span>
</span></span></code></pre></div><h2 id=deserialization>Deserialization<a hidden class=anchor aria-hidden=true href=#deserialization>#</a></h2><p>We&rsquo;ve done serialization, so we should be about halfway done, right? Ha! Because we&rsquo;ve signed up for <em>typed</em> deserialization, which will let us faithfully round-trip some objects, we have more work to do.</p><p>A plain &ldquo;roundtrip&rdquo; like <code>json.loads</code> only gets us part of the way there:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> json<span style=color:#f92672>.</span>loads(serialized)
</span></span><span style=display:flex><span>{<span style=color:#e6db74>&#39;version&#39;</span>: <span style=color:#e6db74>&#39;3&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;array_metadata&#39;</span>: {<span style=color:#e6db74>&#39;shape&#39;</span>: [<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>], <span style=color:#e6db74>&#39;timestamp&#39;</span>: <span style=color:#e6db74>&#39;2000-01-01T00:00:00&#39;</span>},
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;encoder&#39;</span>: {<span style=color:#e6db74>&#39;value&#39;</span>: <span style=color:#ae81ff>1</span>},
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;attributes&#39;</span>: {<span style=color:#e6db74>&#39;foo&#39;</span>: <span style=color:#e6db74>&#39;bar&#39;</span>},
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;name&#39;</span>: <span style=color:#66d9ef>None</span>}
</span></span></code></pre></div><p>We have plain dictionaries instead of instances of our dataclasses and the
timestamp is still a string. In short, we need to decode all the values we
encoded earlier. To do that, we need the user to give us a <em>bit</em> more
information: We need to know the desired dataclass to deserialize into.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>deserialize</span>(into: type[T], data: bytes) <span style=color:#f92672>-&gt;</span> T:
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>Given some type <code>T</code> (which we&rsquo;ll assume is a dataclass; we could do some things
with type annotations to actually check that) like <code>Metadata</code>, we&rsquo;ll build
an instance using the deserialized data (with the properly decoded types!)</p><p>Users will call that like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> deserialize(into<span style=color:#f92672>=</span>Metadata, data<span style=color:#f92672>=</span>deserialized)
</span></span><span style=display:flex><span>Metadata(<span style=color:#f92672>...</span>)
</span></span></code></pre></div><p>For a dataclass type like <code>Metadata</code>, we can get the types of all of its
fields at runtime with <a href=https://docs.python.org/3/library/typing.html#typing.get_type_hints><code>typing.get_type_hints</code></a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> typing<span style=color:#f92672>.</span>get_type_hints(Metadata)
</span></span><span style=display:flex><span>{<span style=color:#e6db74>&#39;version&#39;</span>: typing<span style=color:#f92672>.</span>Literal[<span style=color:#e6db74>&#39;3&#39;</span>],
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;array_metadata&#39;</span>: __main__<span style=color:#f92672>.</span>ArrayMetadata,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;encoder&#39;</span>: __main__<span style=color:#f92672>.</span>EncoderA <span style=color:#f92672>|</span> __main__<span style=color:#f92672>.</span>EncoderB,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;attributes&#39;</span>: dict[str, typing<span style=color:#f92672>.</span>Any],
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;name&#39;</span>: str <span style=color:#f92672>|</span> <span style=color:#66d9ef>None</span>}
</span></span></code></pre></div><p>So we &ldquo;just&rdquo; need to write a <code>decode_value</code> function that mirrors our
<code>encode_value</code> function from earlier.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>decode_value</span>(into: type[T], value: Any) <span style=color:#f92672>-&gt;</span> T:
</span></span><span style=display:flex><span>    <span style=color:#75715e># the default implementation just calls the constructor, like int(x)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># In practice, you have to deal with a lot more details like</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Any, Literal, etc.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> into(value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@decode_value.register</span>(datetime<span style=color:#f92672>.</span>datetime)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@decode_value.register</span>(datetime<span style=color:#f92672>.</span>date)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_</span>(into, value):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> into<span style=color:#f92672>.</span>fromisoformat(value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@decode_value.register</span>(complex)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_</span>(into, value):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> into(<span style=color:#f92672>*</span>value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ... additional implementations</span>
</span></span></code></pre></div><p>Unfortunately, &ldquo;just&rdquo; writing that decoder proved to be challenging (have I
mentioned that you should be using msgspec for this yet?). Probably the biggest challenge was
dealing with Union types. The msgspec docs cover this really well in its <a href=https://jcristharif.com/msgspec/structs.html#tagged-unions>Tagged Unions</a> section, but I&rsquo;ll give a brief overview.</p><p>Let&rsquo;s take a look at the declaration of <code>encoder</code> again:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@dataclasses.dataclass</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EncoderA</span>:
</span></span><span style=display:flex><span>    value: int
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@dataclasses.dataclass</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EncoderB</span>:
</span></span><span style=display:flex><span>    key: str
</span></span><span style=display:flex><span>    value: int
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Metadata</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    encoder: EncoderA <span style=color:#f92672>|</span> EncoderB
</span></span></code></pre></div><p>Right now, we serialize that as something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JSON data-lang=JSON><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;encoder&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;value&#34;</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With that, it&rsquo;s impossible to choose between <code>EncoderA</code> and <code>EncoderB</code> without
some heuristic like &ldquo;pick the first one&rdquo;, or &ldquo;pick the first one that succeeds&rdquo;.
There&rsquo;s just not enough information available to the decoder. The idea of a
&ldquo;tagged union&rdquo; is to embed a bit more information in the serialized
representation that lets the decoder know which to pick.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JSON data-lang=JSON><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;encoder&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;value&#34;</span>: <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;EncoderA&#34;</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now when the decoder looks at the type hints it&rsquo;ll see <code>EncoderA | EncoderB</code> as
the options, and can pick <code>EncoderA</code> based on the <code>type</code> field in the serialized
object. We have introduced a new complication, though: how do we get <code>type</code> in
there in the first place?</p><p>There&rsquo;s probably multiple ways, but I went with <a href=https://docs.python.org/3/library/typing.html#typing.Annotated><code>typing.Annotated</code></a>. It&rsquo;s not
the most user-friendly, but it lets you put additional metadata on the type
hints, which can be used for whatever you want. We&rsquo;d require the user to specify
the variants of the union types as something like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Tag</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EncoderA</span>:
</span></span><span style=display:flex><span>    value: int
</span></span><span style=display:flex><span>    type: typing<span style=color:#f92672>.</span>Annotated[typing<span style=color:#f92672>.</span>Literal[<span style=color:#e6db74>&#34;a&#34;</span>], Tag] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;a&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EncoderB</span>:
</span></span><span style=display:flex><span>    value: int
</span></span><span style=display:flex><span>    key: str
</span></span><span style=display:flex><span>    type: typing<span style=color:#f92672>.</span>Annotated[typing<span style=color:#f92672>.</span>Literal[<span style=color:#e6db74>&#34;b&#34;</span>], Tag] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;b&#34;</span>
</span></span></code></pre></div><p>(Other libraries might use something like the classes name as the value (by
default) rather than requiring a single-valued Literal there.)</p><p>Now we have a <code>type</code> key that&rsquo;ll show up in the serialized form.
When our decoder encounters a union of types to deserialize into,
it can inspect their types hints with <code>include_extras</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> typing<span style=color:#f92672>.</span>get_type_hints(EncoderA, include_extras<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>{<span style=color:#e6db74>&#39;value&#39;</span>: int,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;type&#39;</span>: typing<span style=color:#f92672>.</span>Annotated[typing<span style=color:#f92672>.</span>Literal[<span style=color:#e6db74>&#39;a&#39;</span>], <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#a6e22e>__main__</span><span style=color:#f92672>.</span>Tag<span style=color:#e6db74>&#39;&gt;]}</span>
</span></span></code></pre></div><p>By walking each of those pairs, the decoder can figure out which
value in <code>type</code> maps to which dataclass type:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> tags_to_types
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;a&#34;</span>: EncoderA,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;b&#34;</span>: EncoderB,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally, given the object <code>{"type": "a", "value": 1}</code> it can pick the correct
dataclass type to use. Then <em>that</em> can be fed through <code>decode_value(EncoderA, value)</code> to recursively decode all of its types properly.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>There&rsquo;s much more to doing this <em>well</em> that I&rsquo;ve skipped over in the name of
simplicity (validation, nested types like <code>list[Metadata]</code> or tuples, good error
messages, performance, extensibility, &mldr;). Once again, you should probably be
using <a href=https://jcristharif.com/msgspec/>msgspec</a> for this. But at least now you might have a bit of an idea how
these libraries work and how type annotations can be used at runtime in Python.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tomaugspurger.net/>Tom's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><a rel=me href=https://mastodon.social/@TomAugspurger></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>