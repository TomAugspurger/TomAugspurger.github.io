<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Practical Pandas Part 2 - More Tidying, More Data, and Merging | Tom's Blog</title>
<meta name=keywords content="python,data science,pandas,practical pandas"><meta name=description content="This is Part 2 in the Practical Pandas Series, where I work through a data analysis problem from start to finish.
It&rsquo;s a misconception that we can cleanly separate the data analysis pipeline into a linear sequence of steps from
data acqusition data tidying exploratory analysis model building production As you work through a problem you&rsquo;ll realize, &ldquo;I need this other bit of data&rdquo;, or &ldquo;this would be easier if I stored the data this way&rdquo;, or more commonly &ldquo;strange, that&rsquo;s not supposed to happen&rdquo;."><meta name=author content><link rel=canonical href=https://tomaugspurger.net/posts/pp02/><link crossorigin=anonymous href=/assets/css/stylesheet.ced21e6d3497ee93fed8f8b357448095840179bd510b5ea0e6013078712e6dd1.css integrity="sha256-ztIebTSX7pP+2PizV0SAlYQBeb1RC16g5gEweHEubdE=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://tomaugspurger.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tomaugspurger.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tomaugspurger.net/favicon-32x32.png><link rel=apple-touch-icon href=https://tomaugspurger.net/apple-touch-icon.png><link rel=mask-icon href=https://tomaugspurger.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tomaugspurger.net/posts/pp02/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Practical Pandas Part 2 - More Tidying, More Data, and Merging"><meta property="og:description" content="This is Part 2 in the Practical Pandas Series, where I work through a data analysis problem from start to finish.
It&rsquo;s a misconception that we can cleanly separate the data analysis pipeline into a linear sequence of steps from
data acqusition data tidying exploratory analysis model building production As you work through a problem you&rsquo;ll realize, &ldquo;I need this other bit of data&rdquo;, or &ldquo;this would be easier if I stored the data this way&rdquo;, or more commonly &ldquo;strange, that&rsquo;s not supposed to happen&rdquo;."><meta property="og:type" content="article"><meta property="og:url" content="https://tomaugspurger.net/posts/pp02/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-09-04T00:00:00+00:00"><meta property="article:modified_time" content="2014-09-04T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Practical Pandas Part 2 - More Tidying, More Data, and Merging"><meta name=twitter:description content="This is Part 2 in the Practical Pandas Series, where I work through a data analysis problem from start to finish.
It&rsquo;s a misconception that we can cleanly separate the data analysis pipeline into a linear sequence of steps from
data acqusition data tidying exploratory analysis model building production As you work through a problem you&rsquo;ll realize, &ldquo;I need this other bit of data&rdquo;, or &ldquo;this would be easier if I stored the data this way&rdquo;, or more commonly &ldquo;strange, that&rsquo;s not supposed to happen&rdquo;."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tomaugspurger.net/posts/"},{"@type":"ListItem","position":2,"name":"Practical Pandas Part 2 - More Tidying, More Data, and Merging","item":"https://tomaugspurger.net/posts/pp02/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Practical Pandas Part 2 - More Tidying, More Data, and Merging","name":"Practical Pandas Part 2 - More Tidying, More Data, and Merging","description":"This is Part 2 in the Practical Pandas Series, where I work through a data analysis problem from start to finish.\nIt\u0026rsquo;s a misconception that we can cleanly separate the data analysis pipeline into a linear sequence of steps from\ndata acqusition data tidying exploratory analysis model building production As you work through a problem you\u0026rsquo;ll realize, \u0026ldquo;I need this other bit of data\u0026rdquo;, or \u0026ldquo;this would be easier if I stored the data this way\u0026rdquo;, or more commonly \u0026ldquo;strange, that\u0026rsquo;s not supposed to happen\u0026rdquo;.","keywords":["python","data science","pandas","practical pandas"],"articleBody":"This is Part 2 in the Practical Pandas Series, where I work through a data analysis problem from start to finish.\nIt’s a misconception that we can cleanly separate the data analysis pipeline into a linear sequence of steps from\ndata acqusition data tidying exploratory analysis model building production As you work through a problem you’ll realize, “I need this other bit of data”, or “this would be easier if I stored the data this way”, or more commonly “strange, that’s not supposed to happen”.\nWe’ll follow up our last post by circling back to cleaning up our data set, and fetching some more data. Here’s a reminder of where we were.\n%matplotlib inline import numpy as np import pandas as pd import seaborn as sns import matplotlib.pyplot as plt df = pd.read_hdf('data/cycle_store.h5', key='merged') df.head() Time Ride Time Ride Time (secs) Stopped Time Stopped Time (secs) Latitude Longitude Elevation (feet) Distance (miles) Speed (mph) Pace Pace (secs) Average Speed (mph) Average Pace Average Pace (secs) Ascent (feet) Descent (feet) Calories ride_id 0 2013-08-01 07:07:10 2014-09-02 00:00:01 1.1 2014-09-02 0 41.703753 -91.609892 963 0.00 2.88 2014-09-02 00:20:51 1251 0.00 2014-09-02 00:00:00 0 0 0 0 0 1 2013-08-01 07:07:17 2014-09-02 00:00:08 8.2 2014-09-02 0 41.703825 -91.609835 852 0.01 2.88 2014-09-02 00:20:51 1251 2.56 2014-09-02 00:23:27 1407 0 129 0 0 2 2013-08-01 07:07:22 2014-09-02 00:00:13 13.2 2014-09-02 0 41.703858 -91.609814 789 0.01 2.88 2014-09-02 00:20:51 1251 2.27 2014-09-02 00:26:27 1587 0 173 0 0 3 2013-08-01 07:07:27 2014-09-02 00:00:18 18.2 2014-09-02 0 41.703943 -91.610090 787 0.02 6.60 2014-09-02 00:09:06 546 4.70 2014-09-02 00:12:47 767 0 173 1 0 4 2013-08-01 07:07:40 2014-09-02 00:00:31 31.2 2014-09-02 0 41.704381 -91.610258 788 0.06 9.50 2014-09-02 00:06:19 379 6.37 2014-09-02 00:09:26 566 0 173 2 0 Because of a bug in pandas, we lost our timzone information when we filled in our missing values. Until that’s fixed we’ll have to manually add back the timezone info and convert.\nI like to keep my DataFrame columns as valid python identifiers. Let’s define a helper function to rename the columns. We also have a few redundant columns that we can drop.\ndf = df.drop(['Ride Time', 'Stopped Time', 'Pace', 'Average Pace'], axis=1) def renamer(name): for char in ['(', ')']: name = name.replace(char, '') name = name.replace(' ', '_') name = name.lower() return name df = df.rename(columns=renamer) list(df.columns) ['time', 'ride_time_secs', 'stopped_time_secs', 'latitude', 'longitude', 'elevation_feet', 'distance_miles', 'speed_mph', 'pace_secs', 'average_speed_mph', 'average_pace_secs', 'ascent_feet', 'descent_feet', 'calories', 'ride_id'] Do you trust the data? Remember that I needed to manually start and stop the timer each ride, which natuarlly means that I messed this up at least once. Let’s see if we can figure out the rides where I messed things up. The first heuristic we’ll use is checking to see if I moved at all.\nAll of my rides should have take roughly the same about of time. Let’s get an idea of how the distribution of ride times look. We’ll look at both the ride time and the time I spent stopped. If I spend a long time in the same place, there’s a good chance that I finished my ride and forgot to stop the timer.\ntime_pal = sns.color_palette(n_colors=2) # Plot it in mintues fig, axes = plt.subplots(ncols=2, figsize=(13, 5)) # max to get the last observation per ride since we know these are increasing times = df.groupby('ride_id')[['stopped_time_secs', 'ride_time_secs']].max() times['ride_time_secs'].plot(kind='bar', ax=axes[0], color=time_pal[0]) axes[0].set_title(\"Ride Time\") times['stopped_time_secs'].plot(kind='bar', ax=axes[1], color=time_pal[1]) axes[1].set_title(\"Stopped Time\") Let’s dig into that spike in the stopped time. We’ll get it’s ride id with the Series.argmax method.\nidx = times.stopped_time_secs.argmax() long_stop = df[df.ride_id == idx] ax = long_stop.set_index('time')['distance_miles'].plot() avg_distance = df.groupby('ride_id').distance_miles.max().mean() ax.set_ylabel(\"Distance (miles)\") ax.hlines(avg_distance, *ax.get_xlim()) So it looks like I started my timer, sat around for about 15 minutes, and then continued with my normal ride (I verified that by plotting the average distance travelled per ride, and it was right on target).\nWe can use most of the columns fine, it’s just the the time column we need to be careful with. Let’s make an adjusted time column time_adj that accounts for the stopped time.\nimport datetime def as_timedelta(x): return datetime.timedelta(0, x // 1, x % 1) df['time_adj'] = df.time - df.stopped_time_secs.apply(as_timedelta) df.head() time ride_time_secs stopped_time_secs latitude longitude elevation_feet distance_miles speed_mph pace_secs average_speed_mph average_pace_secs ascent_feet descent_feet calories ride_id time_adj 0 2013-08-01 07:07:10 1.1 0 41.703753 -91.609892 963 0.00 2.88 1251 0.00 0 0 0 0 0 2013-08-01 07:07:10 1 2013-08-01 07:07:17 8.2 0 41.703825 -91.609835 852 0.01 2.88 1251 2.56 1407 0 129 0 0 2013-08-01 07:07:17 2 2013-08-01 07:07:22 13.2 0 41.703858 -91.609814 789 0.01 2.88 1251 2.27 1587 0 173 0 0 2013-08-01 07:07:22 3 2013-08-01 07:07:27 18.2 0 41.703943 -91.610090 787 0.02 6.60 546 4.70 767 0 173 1 0 2013-08-01 07:07:27 4 2013-08-01 07:07:40 31.2 0 41.704381 -91.610258 788 0.06 9.50 379 6.37 566 0 173 2 0 2013-08-01 07:07:40 When we start using the actual GPS data, we may need to do some smoothing. These are just readings from my iPhone, which probably aren’t that accurate. Kalman filters, which I learned about in my econometrics class, are commonly used for this purpose. But I think that’s good enough for now.\nGetting More Data I’m interested in explaining the variation in how long it took me to make the ride. I hypothesize that the weather may have had something to do with it. We’ll fetch data from forecas.io using their API to get the weather conditions at the time of each ride.\nI looked at the forecast.io documentation, and noticed that the API will require a timezone. We could proceed in two ways\nSet df.time to be the index (a DatetimeIndex). Then localize with df.tz_localize Pass df.time through the DatetimeIndex constructor to set the timezone, and set that to be a column in df. Ideally we’d go with 1. Pandas has a lot of great additoinal functionality to offer when you have a DatetimeIndex (such as resample). However, this conflicts with the desire to have a unique index with this specific dataset. The times recorded are at the second frequency, but there are occasionally multiple readings in a second.\n# should be 0 if there are no repeats. len(df.time) - len(df.time.unique()) 114 So we’ll go with #2, running the time column through the DatetimeIndex constructor, which has a tz (timezone) parameter, and placing that in a ’time’ column. I’m in the US/Central timezone.\ndf['time'] = pd.DatetimeIndex(df.time, tz='US/Central') df.head() time ride_time_secs stopped_time_secs latitude longitude elevation_feet distance_miles speed_mph pace_secs average_speed_mph average_pace_secs ascent_feet descent_feet calories ride_id time_adj 0 2013-08-01 07:07:10-05:00 1.1 0 41.703753 -91.609892 963 0.00 2.88 1251 0.00 0 0 0 0 0 2013-08-01 07:07:10 1 2013-08-01 07:07:17-05:00 8.2 0 41.703825 -91.609835 852 0.01 2.88 1251 2.56 1407 0 129 0 0 2013-08-01 07:07:17 2 2013-08-01 07:07:22-05:00 13.2 0 41.703858 -91.609814 789 0.01 2.88 1251 2.27 1587 0 173 0 0 2013-08-01 07:07:22 3 2013-08-01 07:07:27-05:00 18.2 0 41.703943 -91.610090 787 0.02 6.60 546 4.70 767 0 173 1 0 2013-08-01 07:07:27 4 2013-08-01 07:07:40-05:00 31.2 0 41.704381 -91.610258 788 0.06 9.50 379 6.37 566 0 173 2 0 2013-08-01 07:07:40 There’s nothing specific to pandas here, but knowing the basics of calling an API and parsing the response is still useful. We’ll use requests to make the API call. You’ll need to register for you own API key. I keep mine in a JSON file in my Dropbox bin folder.\nFor this specific call we need to give the Latitude, Longitude, and Time that we want the weather for. We fill in those to a url with the format https://api.forecast.io/forecast/{key}/{Latitude},{Longitude},{Time}.\nimport json import requests with open('/Users/tom/Dropbox/bin/api-keys.txt') as f: key = json.load(f)['forecast.io'] url = \"https://api.forecast.io/forecast/{key}/{Latitude},{Longitude},{Time}\" vals = df.loc[0, ['latitude', 'longitude', 'time']].rename(lambda x: x.title()).to_dict() vals['Time'] = str(vals['Time']).replace(' ', 'T') vals['key'] = key r = requests.get(url.format(**vals)) resp = r.json() resp.keys() dict_keys(['timezone', 'longitude', 'hourly', 'offset', 'currently', 'daily', 'latitude', 'flags']) Here’s the plan. For each ride, we’ll get the current conditions at the time, latitude, and longitude of departure. We’ll use those values for the entirety of that ride.\nI’m a bit concerned about the variance of some quantities from the weather data (like the windspeed and bearing). This would be something to look into for a serious analysis. If the quantities are highly variable you would want to take a rolling average over more datapoints. forecast.io limits you to 1,000 API calls per day though (at the free tier), so we’ll just stick with one request per ride.\ndef get_weather(df, ride_id, key): \"\"\" Get the current weather conditions for for a ride at the time of departure. \"\"\" url = \"https://api.forecast.io/forecast/{key}/{Latitude},{Longitude},{Time}\" vals = df.query(\"ride_id == @ride_id\").iloc[0][['latitude', 'longitude', 'time']].rename(lambda x: x.title()).to_dict() vals['key'] = key vals['Time'] = str(vals['Time']).replace(' ', 'T') r = requests.get(url.format(**vals)) resp = r.json()['currently'] return resp Let’s test it out:\nget_weather(df, df.ride_id.unique()[0], key) {'apparentTemperature': 61.62, 'precipProbability': 0, 'summary': 'Clear', 'cloudCover': 0, 'windSpeed': 2.77, 'windBearing': 282, 'dewPoint': 58.66, 'pressure': 1017.62, 'icon': 'clear-day', 'humidity': 0.9, 'visibility': 8.89, 'time': 1375358830, 'temperature': 61.62, 'precipIntensity': 0} Now do that for each ride_id, and store the result in a DataFrame\nconditions = [get_weather(df, ride_id, key) for ride_id in df.ride_id.unique()] weather = pd.DataFrame(conditions) weather.head() Let’s fixup the dtype on the time column. We need to convert from the seconds to a datetime. Then handle the timezone like before. This is returned in ‘UTC’, so we’ll bring it back to my local time with .tz_convert.\nweather['time'] = pd.DatetimeIndex(pd.to_datetime(weather.time, unit='s'), tz='UTC').\\ tz_convert('US/Central') Now we can merge the two DataFrames weather and df. In this case it’s quite simple since the share a single column, time. Pandas behaves exactly as you’d expect, merging on the provided column. We take the outer join since we only have weather information for the first obervation of each ride. We’ll fill those values forward for the entirety of the ride.\nI don’t just call with_weather.fillna() since the non-weather columns have NaNs that we may want to treat separately.\nwith_weather = pd.merge(df, weather, on='time', how='outer') print(with_weather.time.dtype) with_weather[weather.columns] = with_weather[weather.columns].fillna(method='ffill') print(with_weather.time.dtype) with_weather.time.head() with_weather.time.head() With that done, let’s write with_weather out to disk. We’ll get a Performance Warning since some of the columns are text, which are relatively slow for HDF5, but it’s not a problem worht worrying about for a dataset this small. If you needed you could encode the text ones as integers with pd.factorize, write the integers out the the HDF5 store, and store the mapping from integer to text description elsewhere.\nwith_weather.to_hdf('data/cycle_store.h5', key='with_weather', append=False, format='table') weather.to_hdf('data/cycle_store.h5', key='weather', append=False, format='table') A bit of Exploring We’ve done a lot of data wrangling with a notable lack of pretty pictures to look at. Let’s fix that.\nsns.puppyplot() For some other (less) pretty pictures, let’s visualize some of the weather data we collected.\nsns.set(style=\"white\") cols = ['temperature', 'apparentTemperature', 'humidity', 'dewPoint', 'pressure'] # 'pressure', 'windBearing', 'windSpeed']].reset_index(drop=True)) g = sns.PairGrid(weather.reset_index()[cols]) g.map_diag(plt.hist) g.map_lower(sns.kdeplot, cmap=\"Blues_d\") g.map_upper(plt.scatter) Not bad! Seaborn makes exploring these relationships very easy.\nLet’s also take a look at the wind data. I’m not a metorologist, but I saw a plot one time that’s like a histogram for wind directions, but plotted on a polar axis (brings back memories of Calc II). Fortunately for us, matplotlib handles polar plots pretty easily, we just have to setup the axes and hand it the values as radians.\nax = plt.subplot(polar=True) ax.set_theta_zero_location('N') ax.set_theta_direction('clockwise') bins = np.arange(0, 361, 30) ax.hist(np.radians(weather.windBearing.dropna()), bins=np.radians(bins)) ax.set_title(\"Direction of Wind Origin\") windBearing represent the direction the wind is coming from so the most common direction is from the S/SW. It may be clearer to flip that around to represent the wind direction; I’m not sure what’s standard.\nIf we were feeling ambitious, we could try to color the wedges by the windspeed. Let’s give it a shot!\nWe’ll need to get the average wind speed in each of our bins from above. This is clearly a groupby, but what excatly is the grouper? This is where pandas Catagorical comes in handy. We’ll pd.cut the wind direction, and group the wind data by that.\nwind = weather[['windSpeed', 'windBearing']].dropna() ct = pd.cut(wind.windBearing, bins) speeds = wind.groupby(ct)['windSpeed'].mean() colors = plt.cm.BuGn(speeds.div(speeds.max())) I map the speeds to colors with one of matplotlib’s colormaps. It expects values in [0, 1], so we normalize the speeds by dividing by the maximum.\nhist doesn’t take a cmap argument, and I couldn’t get color to work, so we’ll just plot it like before, and then modify the color of the patches after the fact.\nfig = plt.figure() ax = plt.subplot(polar=True) ax.set_theta_zero_location('N') ax.set_theta_direction('clockwise') bins = np.arange(0, 360, 30) ax.hist(np.radians(weather.windBearing.dropna()), bins=np.radians(bins)) for p, color in zip(ax.patches, colors): p.set_facecolor(color) ax.set_title(\"Direction of Wind Origin\") Colorbars are tricky in matplotlib (at least for me). So I’m going to leave it at darker is stronger wind.\nThat’s all for now. Come back next time for some exploratory analysis, and if we’re lucky, some maps!\n","wordCount":"2114","inLanguage":"en","datePublished":"2014-09-04T00:00:00Z","dateModified":"2014-09-04T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://tomaugspurger.net/posts/pp02/"},"publisher":{"@type":"Organization","name":"Tom's Blog","logo":{"@type":"ImageObject","url":"https://tomaugspurger.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tomaugspurger.net/ accesskey=h title="Tom's Blog (Alt + H)">Tom's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://tomaugspurger.net/about/ title=About><span>About</span></a></li><li><a href=https://tomaugspurger.net/archives title=Archive><span>Archive</span></a></li><li><a href=https://tomaugspurger.net/index.xml title=RSS><span>RSS</span></a></li><li><a href=https://tomaugspurger.net/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Practical Pandas Part 2 - More Tidying, More Data, and Merging</h1><div class=post-meta><span title='2014-09-04 00:00:00 +0000 UTC'>September 4, 2014</span></div></header><div class=post-content><p><em>This is Part 2 in the Practical Pandas Series, where I work through a data analysis problem from start to finish.</em></p><p>It&rsquo;s a misconception that we can cleanly separate the data analysis pipeline into a linear
sequence of steps from</p><ol><li>data acqusition</li><li>data tidying</li><li>exploratory analysis</li><li>model building</li><li>production</li></ol><p>As you work through a problem you&rsquo;ll realize, &ldquo;I need this other bit of data&rdquo;, or &ldquo;this would be easier if I stored the data this way&rdquo;, or more commonly &ldquo;strange, that&rsquo;s not supposed to happen&rdquo;.</p><p>We&rsquo;ll follow up our <a href=http://tomaugspurger.net/blog/2014/08/26/practical-pandas-part-1-reading-the-data/>last post</a> by circling back to cleaning up our data set, and fetching some more data.
Here&rsquo;s a reminder of where we were.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>%</span>matplotlib inline
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> pandas <span style=color:#66d9ef>as</span> pd
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> seaborn <span style=color:#66d9ef>as</span> sns
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> matplotlib.pyplot <span style=color:#66d9ef>as</span> plt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>read_hdf(<span style=color:#e6db74>&#39;data/cycle_store.h5&#39;</span>, key<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;merged&#39;</span>)
</span></span><span style=display:flex><span>df<span style=color:#f92672>.</span>head()
</span></span></code></pre></div><div style=max-height:1000px;max-width:1500px;overflow:auto><table border=1 class=dataframe><thead><tr style=text-align:right><th></th><th>Time</th><th>Ride Time</th><th>Ride Time (secs)</th><th>Stopped Time</th><th>Stopped Time (secs)</th><th>Latitude</th><th>Longitude</th><th>Elevation (feet)</th><th>Distance (miles)</th><th>Speed (mph)</th><th>Pace</th><th>Pace (secs)</th><th>Average Speed (mph)</th><th>Average Pace</th><th>Average Pace (secs)</th><th>Ascent (feet)</th><th>Descent (feet)</th><th>Calories</th><th>ride_id</th></tr></thead><tbody><tr><th>0</th><td>2013-08-01 07:07:10</td><td>2014-09-02 00:00:01</td><td>1.1</td><td>2014-09-02</td><td>0</td><td>41.703753</td><td>-91.609892</td><td>963</td><td>0.00</td><td>2.88</td><td>2014-09-02 00:20:51</td><td>1251</td><td>0.00</td><td>2014-09-02 00:00:00</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><th>1</th><td>2013-08-01 07:07:17</td><td>2014-09-02 00:00:08</td><td>8.2</td><td>2014-09-02</td><td>0</td><td>41.703825</td><td>-91.609835</td><td>852</td><td>0.01</td><td>2.88</td><td>2014-09-02 00:20:51</td><td>1251</td><td>2.56</td><td>2014-09-02 00:23:27</td><td>1407</td><td>0</td><td>129</td><td>0</td><td>0</td></tr><tr><th>2</th><td>2013-08-01 07:07:22</td><td>2014-09-02 00:00:13</td><td>13.2</td><td>2014-09-02</td><td>0</td><td>41.703858</td><td>-91.609814</td><td>789</td><td>0.01</td><td>2.88</td><td>2014-09-02 00:20:51</td><td>1251</td><td>2.27</td><td>2014-09-02 00:26:27</td><td>1587</td><td>0</td><td>173</td><td>0</td><td>0</td></tr><tr><th>3</th><td>2013-08-01 07:07:27</td><td>2014-09-02 00:00:18</td><td>18.2</td><td>2014-09-02</td><td>0</td><td>41.703943</td><td>-91.610090</td><td>787</td><td>0.02</td><td>6.60</td><td>2014-09-02 00:09:06</td><td>546</td><td>4.70</td><td>2014-09-02 00:12:47</td><td>767</td><td>0</td><td>173</td><td>1</td><td>0</td></tr><tr><th>4</th><td>2013-08-01 07:07:40</td><td>2014-09-02 00:00:31</td><td>31.2</td><td>2014-09-02</td><td>0</td><td>41.704381</td><td>-91.610258</td><td>788</td><td>0.06</td><td>9.50</td><td>2014-09-02 00:06:19</td><td>379</td><td>6.37</td><td>2014-09-02 00:09:26</td><td>566</td><td>0</td><td>173</td><td>2</td><td>0</td></tr></tbody></table></div><p>Because of a <a href=https://github.com/pydata/pandas/issues/8189>bug</a> in pandas, we lost our timzone information when we filled in our missing values. Until that&rsquo;s fixed we&rsquo;ll have to manually add back the timezone info and convert.</p><p>I like to keep my DataFrame columns as valid python identifiers.
Let&rsquo;s define a helper function to rename the columns. We also have a few redundant columns that we can drop.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>drop([<span style=color:#e6db74>&#39;Ride Time&#39;</span>, <span style=color:#e6db74>&#39;Stopped Time&#39;</span>, <span style=color:#e6db74>&#39;Pace&#39;</span>, <span style=color:#e6db74>&#39;Average Pace&#39;</span>], axis<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>renamer</span>(name):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> char <span style=color:#f92672>in</span> [<span style=color:#e6db74>&#39;(&#39;</span>, <span style=color:#e6db74>&#39;)&#39;</span>]:
</span></span><span style=display:flex><span>        name <span style=color:#f92672>=</span> name<span style=color:#f92672>.</span>replace(char, <span style=color:#e6db74>&#39;&#39;</span>)
</span></span><span style=display:flex><span>    name <span style=color:#f92672>=</span> name<span style=color:#f92672>.</span>replace(<span style=color:#e6db74>&#39; &#39;</span>, <span style=color:#e6db74>&#39;_&#39;</span>)
</span></span><span style=display:flex><span>    name <span style=color:#f92672>=</span> name<span style=color:#f92672>.</span>lower()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> name
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>rename(columns<span style=color:#f92672>=</span>renamer)
</span></span><span style=display:flex><span>list(df<span style=color:#f92672>.</span>columns)
</span></span></code></pre></div><pre><code>['time',
 'ride_time_secs',
 'stopped_time_secs',
 'latitude',
 'longitude',
 'elevation_feet',
 'distance_miles',
 'speed_mph',
 'pace_secs',
 'average_speed_mph',
 'average_pace_secs',
 'ascent_feet',
 'descent_feet',
 'calories',
 'ride_id']
</code></pre><h3 id=do-you-trust-the-data>Do you trust the data?<a hidden class=anchor aria-hidden=true href=#do-you-trust-the-data>#</a></h3><p>Remember that I needed to manually start and stop the timer each ride, which natuarlly means that I messed this up at least once. Let&rsquo;s see if we can figure out the rides where I messed things up.
The first heuristic we&rsquo;ll use is checking to see if I moved at all.</p><p>All of my rides should have take roughly the same about of time. Let&rsquo;s get an idea of how the distribution of ride times look. We&rsquo;ll look at both the ride time and the time I spent stopped.
If I spend a long time in the same place, there&rsquo;s a good chance that I finished my ride and forgot to stop the timer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>time_pal <span style=color:#f92672>=</span> sns<span style=color:#f92672>.</span>color_palette(n_colors<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Plot it in mintues</span>
</span></span><span style=display:flex><span>fig, axes <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplots(ncols<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>, figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># max to get the last observation per ride since we know these are increasing</span>
</span></span><span style=display:flex><span>times <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>groupby(<span style=color:#e6db74>&#39;ride_id&#39;</span>)[[<span style=color:#e6db74>&#39;stopped_time_secs&#39;</span>, <span style=color:#e6db74>&#39;ride_time_secs&#39;</span>]]<span style=color:#f92672>.</span>max()
</span></span><span style=display:flex><span>times[<span style=color:#e6db74>&#39;ride_time_secs&#39;</span>]<span style=color:#f92672>.</span>plot(kind<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;bar&#39;</span>, ax<span style=color:#f92672>=</span>axes[<span style=color:#ae81ff>0</span>], color<span style=color:#f92672>=</span>time_pal[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>axes[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>set_title(<span style=color:#e6db74>&#34;Ride Time&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>times[<span style=color:#e6db74>&#39;stopped_time_secs&#39;</span>]<span style=color:#f92672>.</span>plot(kind<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;bar&#39;</span>, ax<span style=color:#f92672>=</span>axes[<span style=color:#ae81ff>1</span>], color<span style=color:#f92672>=</span>time_pal[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>axes[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>set_title(<span style=color:#e6db74>&#34;Stopped Time&#34;</span>)
</span></span></code></pre></div><pre><code>&lt;matplotlib.text.Text at 0x11531f3c8&gt;
</code></pre><p><img loading=lazy src=pp02_files/pp02_7_1.png alt=png></p><p>Let&rsquo;s dig into that spike in the stopped time. We&rsquo;ll get it&rsquo;s ride id with the <code>Series.argmax</code> method.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>idx <span style=color:#f92672>=</span> times<span style=color:#f92672>.</span>stopped_time_secs<span style=color:#f92672>.</span>argmax()
</span></span><span style=display:flex><span>long_stop <span style=color:#f92672>=</span> df[df<span style=color:#f92672>.</span>ride_id <span style=color:#f92672>==</span> idx]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ax <span style=color:#f92672>=</span> long_stop<span style=color:#f92672>.</span>set_index(<span style=color:#e6db74>&#39;time&#39;</span>)[<span style=color:#e6db74>&#39;distance_miles&#39;</span>]<span style=color:#f92672>.</span>plot()
</span></span><span style=display:flex><span>avg_distance <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>groupby(<span style=color:#e6db74>&#39;ride_id&#39;</span>)<span style=color:#f92672>.</span>distance_miles<span style=color:#f92672>.</span>max()<span style=color:#f92672>.</span>mean()
</span></span><span style=display:flex><span>ax<span style=color:#f92672>.</span>set_ylabel(<span style=color:#e6db74>&#34;Distance (miles)&#34;</span>)
</span></span><span style=display:flex><span>ax<span style=color:#f92672>.</span>hlines(avg_distance, <span style=color:#f92672>*</span>ax<span style=color:#f92672>.</span>get_xlim())
</span></span></code></pre></div><pre><code>&lt;matplotlib.collections.LineCollection at 0x115004160&gt;
</code></pre><p><img loading=lazy src=pp02_files/pp02_9_1.png alt=png></p><p>So it looks like I started my timer, sat around for about 15 minutes, and then continued with my normal ride (I verified that by plotting the average distance travelled per ride, and it was right on target).</p><p>We can use most of the columns fine, it&rsquo;s just the the <code>time</code> column we need to be careful with. Let&rsquo;s
make an adjusted time column <code>time_adj</code> that accounts for the stopped time.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> datetime
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>as_timedelta</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> datetime<span style=color:#f92672>.</span>timedelta(<span style=color:#ae81ff>0</span>, x <span style=color:#f92672>//</span> <span style=color:#ae81ff>1</span>, x <span style=color:#f92672>%</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>df[<span style=color:#e6db74>&#39;time_adj&#39;</span>] <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>time <span style=color:#f92672>-</span> df<span style=color:#f92672>.</span>stopped_time_secs<span style=color:#f92672>.</span>apply(as_timedelta)
</span></span><span style=display:flex><span>df<span style=color:#f92672>.</span>head()
</span></span></code></pre></div><div style=max-height:1000px;max-width:1500px;overflow:auto><table border=1 class=dataframe><thead><tr style=text-align:right><th></th><th>time</th><th>ride_time_secs</th><th>stopped_time_secs</th><th>latitude</th><th>longitude</th><th>elevation_feet</th><th>distance_miles</th><th>speed_mph</th><th>pace_secs</th><th>average_speed_mph</th><th>average_pace_secs</th><th>ascent_feet</th><th>descent_feet</th><th>calories</th><th>ride_id</th><th>time_adj</th></tr></thead><tbody><tr><th>0</th><td>2013-08-01 07:07:10</td><td>1.1</td><td>0</td><td>41.703753</td><td>-91.609892</td><td>963</td><td>0.00</td><td>2.88</td><td>1251</td><td>0.00</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>2013-08-01 07:07:10</td></tr><tr><th>1</th><td>2013-08-01 07:07:17</td><td>8.2</td><td>0</td><td>41.703825</td><td>-91.609835</td><td>852</td><td>0.01</td><td>2.88</td><td>1251</td><td>2.56</td><td>1407</td><td>0</td><td>129</td><td>0</td><td>0</td><td>2013-08-01 07:07:17</td></tr><tr><th>2</th><td>2013-08-01 07:07:22</td><td>13.2</td><td>0</td><td>41.703858</td><td>-91.609814</td><td>789</td><td>0.01</td><td>2.88</td><td>1251</td><td>2.27</td><td>1587</td><td>0</td><td>173</td><td>0</td><td>0</td><td>2013-08-01 07:07:22</td></tr><tr><th>3</th><td>2013-08-01 07:07:27</td><td>18.2</td><td>0</td><td>41.703943</td><td>-91.610090</td><td>787</td><td>0.02</td><td>6.60</td><td>546</td><td>4.70</td><td>767</td><td>0</td><td>173</td><td>1</td><td>0</td><td>2013-08-01 07:07:27</td></tr><tr><th>4</th><td>2013-08-01 07:07:40</td><td>31.2</td><td>0</td><td>41.704381</td><td>-91.610258</td><td>788</td><td>0.06</td><td>9.50</td><td>379</td><td>6.37</td><td>566</td><td>0</td><td>173</td><td>2</td><td>0</td><td>2013-08-01 07:07:40</td></tr></tbody></table></div><p>When we start using the actual GPS data, we may need to do some smoothing.
These are just readings from my iPhone, which probably aren&rsquo;t that accurate. <a href=http://en.wikipedia.org/wiki/Kalman_filter>Kalman filters</a>, which I learned about in my econometrics class, are commonly used for this purpose.
But I think that&rsquo;s good enough for now.</p><h3 id=getting-more-data>Getting More Data<a hidden class=anchor aria-hidden=true href=#getting-more-data>#</a></h3><p>I&rsquo;m interested in explaining the variation in how long it took me to make the ride.
I hypothesize that the weather may have had something to do with it. We&rsquo;ll fetch data from <a href=http://forecast.io>forecas.io</a> using their <a href=https://developer.forecast.io>API</a> to get the weather conditions at the time of each ride.</p><p>I looked at the <a href=https://developer.forecast.io/docs/v2>forecast.io documentation</a>, and noticed that the API will require a timezone. We could proceed in two ways</p><ol><li>Set <code>df.time</code> to be the index (a DatetimeIndex). Then localize with <code>df.tz_localize</code></li><li>Pass <code>df.time</code> through the DatetimeIndex constructor to set the timezone, and set that to be a column in df.</li></ol><p>Ideally we&rsquo;d go with 1. Pandas has a lot of great additoinal functionality to offer when you have a DatetimeIndex (such as <code>resample</code>).
However, this conflicts with the desire to have a unique index with this specific dataset. The times recorded are at the second frequency, but there are occasionally multiple readings in a second.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># should be 0 if there are no repeats.</span>
</span></span><span style=display:flex><span>len(df<span style=color:#f92672>.</span>time) <span style=color:#f92672>-</span> len(df<span style=color:#f92672>.</span>time<span style=color:#f92672>.</span>unique())
</span></span></code></pre></div><pre><code>114
</code></pre><p>So we&rsquo;ll go with #2, running the <code>time</code> column through the <code>DatetimeIndex</code> constructor, which has a <code>tz</code> (timezone) parameter, and placing that in a &rsquo;time&rsquo; column. I&rsquo;m in the <code>US/Central</code> timezone.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>df[<span style=color:#e6db74>&#39;time&#39;</span>] <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DatetimeIndex(df<span style=color:#f92672>.</span>time, tz<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;US/Central&#39;</span>)
</span></span><span style=display:flex><span>df<span style=color:#f92672>.</span>head()
</span></span></code></pre></div><div style=max-height:1000px;max-width:1500px;overflow:auto><table border=1 class=dataframe><thead><tr style=text-align:right><th></th><th>time</th><th>ride_time_secs</th><th>stopped_time_secs</th><th>latitude</th><th>longitude</th><th>elevation_feet</th><th>distance_miles</th><th>speed_mph</th><th>pace_secs</th><th>average_speed_mph</th><th>average_pace_secs</th><th>ascent_feet</th><th>descent_feet</th><th>calories</th><th>ride_id</th><th>time_adj</th></tr></thead><tbody><tr><th>0</th><td>2013-08-01 07:07:10-05:00</td><td>1.1</td><td>0</td><td>41.703753</td><td>-91.609892</td><td>963</td><td>0.00</td><td>2.88</td><td>1251</td><td>0.00</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>2013-08-01 07:07:10</td></tr><tr><th>1</th><td>2013-08-01 07:07:17-05:00</td><td>8.2</td><td>0</td><td>41.703825</td><td>-91.609835</td><td>852</td><td>0.01</td><td>2.88</td><td>1251</td><td>2.56</td><td>1407</td><td>0</td><td>129</td><td>0</td><td>0</td><td>2013-08-01 07:07:17</td></tr><tr><th>2</th><td>2013-08-01 07:07:22-05:00</td><td>13.2</td><td>0</td><td>41.703858</td><td>-91.609814</td><td>789</td><td>0.01</td><td>2.88</td><td>1251</td><td>2.27</td><td>1587</td><td>0</td><td>173</td><td>0</td><td>0</td><td>2013-08-01 07:07:22</td></tr><tr><th>3</th><td>2013-08-01 07:07:27-05:00</td><td>18.2</td><td>0</td><td>41.703943</td><td>-91.610090</td><td>787</td><td>0.02</td><td>6.60</td><td>546</td><td>4.70</td><td>767</td><td>0</td><td>173</td><td>1</td><td>0</td><td>2013-08-01 07:07:27</td></tr><tr><th>4</th><td>2013-08-01 07:07:40-05:00</td><td>31.2</td><td>0</td><td>41.704381</td><td>-91.610258</td><td>788</td><td>0.06</td><td>9.50</td><td>379</td><td>6.37</td><td>566</td><td>0</td><td>173</td><td>2</td><td>0</td><td>2013-08-01 07:07:40</td></tr></tbody></table></div><p>There&rsquo;s nothing specific to pandas here, but knowing the basics of calling an API and parsing the response is still useful.
We&rsquo;ll use <a href=http://docs.python-requests.org/en/latest/>requests</a> to make the
API call. You&rsquo;ll need to register for you own API key. I keep mine in a JSON file in my Dropbox bin folder.</p><p>For this specific call we need to give the Latitude, Longitude, and Time that we want the weather for.
We fill in those to a url with the format <code>https://api.forecast.io/forecast/{key}/{Latitude},{Longitude},{Time}</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> json
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> requests
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#39;/Users/tom/Dropbox/bin/api-keys.txt&#39;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>    key <span style=color:#f92672>=</span> json<span style=color:#f92672>.</span>load(f)[<span style=color:#e6db74>&#39;forecast.io&#39;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://api.forecast.io/forecast/</span><span style=color:#e6db74>{key}</span><span style=color:#e6db74>/</span><span style=color:#e6db74>{Latitude}</span><span style=color:#e6db74>,</span><span style=color:#e6db74>{Longitude}</span><span style=color:#e6db74>,</span><span style=color:#e6db74>{Time}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vals <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[<span style=color:#ae81ff>0</span>, [<span style=color:#e6db74>&#39;latitude&#39;</span>, <span style=color:#e6db74>&#39;longitude&#39;</span>, <span style=color:#e6db74>&#39;time&#39;</span>]]<span style=color:#f92672>.</span>rename(<span style=color:#66d9ef>lambda</span> x: x<span style=color:#f92672>.</span>title())<span style=color:#f92672>.</span>to_dict()
</span></span><span style=display:flex><span>vals[<span style=color:#e6db74>&#39;Time&#39;</span>] <span style=color:#f92672>=</span> str(vals[<span style=color:#e6db74>&#39;Time&#39;</span>])<span style=color:#f92672>.</span>replace(<span style=color:#e6db74>&#39; &#39;</span>, <span style=color:#e6db74>&#39;T&#39;</span>)
</span></span><span style=display:flex><span>vals[<span style=color:#e6db74>&#39;key&#39;</span>] <span style=color:#f92672>=</span> key
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>r <span style=color:#f92672>=</span> requests<span style=color:#f92672>.</span>get(url<span style=color:#f92672>.</span>format(<span style=color:#f92672>**</span>vals))
</span></span><span style=display:flex><span>resp <span style=color:#f92672>=</span> r<span style=color:#f92672>.</span>json()
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>resp<span style=color:#f92672>.</span>keys()
</span></span></code></pre></div><pre><code>dict_keys(['timezone', 'longitude', 'hourly', 'offset', 'currently', 'daily', 'latitude', 'flags'])
</code></pre><p>Here&rsquo;s the plan. For each ride, we&rsquo;ll get the current conditions at the time, latitude, and longitude of departure.
We&rsquo;ll use those values for the entirety of that ride.</p><p>I&rsquo;m a bit concerned about the variance of some quantities from the weather data (like the windspeed and bearing). This would be something to look into for a serious analysis. If the quantities are highly variable you would want to take a rolling average over more datapoints. <code>forecast.io</code> limits you to 1,000 API calls per day though (at the free tier), so we&rsquo;ll just stick with one request per ride.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_weather</span>(df, ride_id, key):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Get the current weather conditions for for a ride at the time of departure.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://api.forecast.io/forecast/</span><span style=color:#e6db74>{key}</span><span style=color:#e6db74>/</span><span style=color:#e6db74>{Latitude}</span><span style=color:#e6db74>,</span><span style=color:#e6db74>{Longitude}</span><span style=color:#e6db74>,</span><span style=color:#e6db74>{Time}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    vals <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>query(<span style=color:#e6db74>&#34;ride_id == @ride_id&#34;</span>)<span style=color:#f92672>.</span>iloc[<span style=color:#ae81ff>0</span>][[<span style=color:#e6db74>&#39;latitude&#39;</span>,
</span></span><span style=display:flex><span>               <span style=color:#e6db74>&#39;longitude&#39;</span>, <span style=color:#e6db74>&#39;time&#39;</span>]]<span style=color:#f92672>.</span>rename(<span style=color:#66d9ef>lambda</span> x: x<span style=color:#f92672>.</span>title())<span style=color:#f92672>.</span>to_dict()
</span></span><span style=display:flex><span>    vals[<span style=color:#e6db74>&#39;key&#39;</span>] <span style=color:#f92672>=</span> key
</span></span><span style=display:flex><span>    vals[<span style=color:#e6db74>&#39;Time&#39;</span>] <span style=color:#f92672>=</span> str(vals[<span style=color:#e6db74>&#39;Time&#39;</span>])<span style=color:#f92672>.</span>replace(<span style=color:#e6db74>&#39; &#39;</span>, <span style=color:#e6db74>&#39;T&#39;</span>)
</span></span><span style=display:flex><span>    r <span style=color:#f92672>=</span> requests<span style=color:#f92672>.</span>get(url<span style=color:#f92672>.</span>format(<span style=color:#f92672>**</span>vals))
</span></span><span style=display:flex><span>    resp <span style=color:#f92672>=</span> r<span style=color:#f92672>.</span>json()[<span style=color:#e6db74>&#39;currently&#39;</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> resp
</span></span></code></pre></div><p>Let&rsquo;s test it out:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>get_weather(df, df<span style=color:#f92672>.</span>ride_id<span style=color:#f92672>.</span>unique()[<span style=color:#ae81ff>0</span>], key)
</span></span></code></pre></div><pre><code>{'apparentTemperature': 61.62,
 'precipProbability': 0,
 'summary': 'Clear',
 'cloudCover': 0,
 'windSpeed': 2.77,
 'windBearing': 282,
 'dewPoint': 58.66,
 'pressure': 1017.62,
 'icon': 'clear-day',
 'humidity': 0.9,
 'visibility': 8.89,
 'time': 1375358830,
 'temperature': 61.62,
 'precipIntensity': 0}
</code></pre><p>Now do that for each <code>ride_id</code>, and store the result in a DataFrame</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>conditions <span style=color:#f92672>=</span> [get_weather(df, ride_id, key) <span style=color:#66d9ef>for</span> ride_id
</span></span><span style=display:flex><span>              <span style=color:#f92672>in</span> df<span style=color:#f92672>.</span>ride_id<span style=color:#f92672>.</span>unique()]
</span></span><span style=display:flex><span>weather <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame(conditions)
</span></span><span style=display:flex><span>weather<span style=color:#f92672>.</span>head()
</span></span></code></pre></div><p>Let&rsquo;s fixup the dtype on the <code>time</code> column. We need to convert from the seconds to a datetime.
Then handle the timezone like before. This is returned in &lsquo;UTC&rsquo;, so we&rsquo;ll bring it back to
my local time with <code>.tz_convert</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>weather[<span style=color:#e6db74>&#39;time&#39;</span>] <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DatetimeIndex(pd<span style=color:#f92672>.</span>to_datetime(weather<span style=color:#f92672>.</span>time, unit<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;s&#39;</span>), tz<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;UTC&#39;</span>)<span style=color:#f92672>.</span>\
</span></span><span style=display:flex><span>                     tz_convert(<span style=color:#e6db74>&#39;US/Central&#39;</span>)
</span></span></code></pre></div><p>Now we can merge the two DataFrames <code>weather</code> and <code>df</code>. In this case it&rsquo;s quite simple since the share a single column, <code>time</code>. Pandas behaves exactly as you&rsquo;d expect, merging on the provided column.
We take the <code>outer</code> join since we only have weather information for the first obervation of each ride.
We&rsquo;ll fill those values forward for the entirety of the ride.</p><p>I don&rsquo;t just call <code>with_weather.fillna()</code> since the non-weather columns have <code>NaN</code>s that we may want to treat separately.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>with_weather <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>merge(df, weather, on<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;time&#39;</span>, how<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;outer&#39;</span>)
</span></span><span style=display:flex><span>print(with_weather<span style=color:#f92672>.</span>time<span style=color:#f92672>.</span>dtype)
</span></span><span style=display:flex><span>with_weather[weather<span style=color:#f92672>.</span>columns] <span style=color:#f92672>=</span> with_weather[weather<span style=color:#f92672>.</span>columns]<span style=color:#f92672>.</span>fillna(method<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;ffill&#39;</span>)
</span></span><span style=display:flex><span>print(with_weather<span style=color:#f92672>.</span>time<span style=color:#f92672>.</span>dtype)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>with_weather<span style=color:#f92672>.</span>time<span style=color:#f92672>.</span>head()
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>with_weather<span style=color:#f92672>.</span>time<span style=color:#f92672>.</span>head()
</span></span></code></pre></div><p>With that done, let&rsquo;s write <code>with_weather</code> out to disk. We&rsquo;ll get a Performance Warning since some of the columns are text, which are relatively slow for HDF5, but it&rsquo;s not a problem worht worrying about for a dataset this small.
If you needed you could encode the text ones as integers with <code>pd.factorize</code>, write the integers out the the HDF5 store, and store the mapping from integer to text description elsewhere.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>with_weather<span style=color:#f92672>.</span>to_hdf(<span style=color:#e6db74>&#39;data/cycle_store.h5&#39;</span>, key<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;with_weather&#39;</span>, append<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>, format<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;table&#39;</span>)
</span></span><span style=display:flex><span>weather<span style=color:#f92672>.</span>to_hdf(<span style=color:#e6db74>&#39;data/cycle_store.h5&#39;</span>, key<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;weather&#39;</span>, append<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>, format<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;table&#39;</span>)
</span></span></code></pre></div><h3 id=a-bit-of-exploring>A bit of Exploring<a hidden class=anchor aria-hidden=true href=#a-bit-of-exploring>#</a></h3><p>We&rsquo;ve done a lot of data wrangling with a notable lack of pretty pictures to look at. Let&rsquo;s fix that.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>sns<span style=color:#f92672>.</span>puppyplot()
</span></span></code></pre></div><p>For some other (less) pretty pictures, let&rsquo;s visualize some of the weather data we collected.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>sns<span style=color:#f92672>.</span>set(style<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;white&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cols <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;temperature&#39;</span>, <span style=color:#e6db74>&#39;apparentTemperature&#39;</span>, <span style=color:#e6db74>&#39;humidity&#39;</span>, <span style=color:#e6db74>&#39;dewPoint&#39;</span>, <span style=color:#e6db74>&#39;pressure&#39;</span>]
</span></span><span style=display:flex><span><span style=color:#75715e># &#39;pressure&#39;, &#39;windBearing&#39;, &#39;windSpeed&#39;]].reset_index(drop=True))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>g <span style=color:#f92672>=</span> sns<span style=color:#f92672>.</span>PairGrid(weather<span style=color:#f92672>.</span>reset_index()[cols])
</span></span><span style=display:flex><span>                          
</span></span><span style=display:flex><span>g<span style=color:#f92672>.</span>map_diag(plt<span style=color:#f92672>.</span>hist)
</span></span><span style=display:flex><span>g<span style=color:#f92672>.</span>map_lower(sns<span style=color:#f92672>.</span>kdeplot, cmap<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Blues_d&#34;</span>)
</span></span><span style=display:flex><span>g<span style=color:#f92672>.</span>map_upper(plt<span style=color:#f92672>.</span>scatter)
</span></span></code></pre></div><p>Not bad! <a href=http://web.stanford.edu/~mwaskom/software/seaborn/>Seaborn</a> makes exploring these relationships very easy.</p><p>Let&rsquo;s also take a look at the wind data. I&rsquo;m not a metorologist, but I saw a plot one time that&rsquo;s like a histogram for wind directions, but plotted on a <a href=http://en.wikipedia.org/wiki/Polar_coordinate_system>polar axis</a> (brings back memories of Calc II). Fortunately for us, matplotlib handles polar plots pretty easily, we just have to setup the
axes and hand it the values as radians.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>ax <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplot(polar<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>ax<span style=color:#f92672>.</span>set_theta_zero_location(<span style=color:#e6db74>&#39;N&#39;</span>)
</span></span><span style=display:flex><span>ax<span style=color:#f92672>.</span>set_theta_direction(<span style=color:#e6db74>&#39;clockwise&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bins <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>arange(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>361</span>, <span style=color:#ae81ff>30</span>)
</span></span><span style=display:flex><span>ax<span style=color:#f92672>.</span>hist(np<span style=color:#f92672>.</span>radians(weather<span style=color:#f92672>.</span>windBearing<span style=color:#f92672>.</span>dropna()), bins<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>radians(bins))
</span></span><span style=display:flex><span>ax<span style=color:#f92672>.</span>set_title(<span style=color:#e6db74>&#34;Direction of Wind Origin&#34;</span>)
</span></span></code></pre></div><p><code>windBearing</code> represent the direction the wind is coming <em>from</em> so the most common direction is from the S/SW. It may be clearer to flip that around to represent the wind direction; I&rsquo;m not sure what&rsquo;s standard.</p><p>If we were feeling ambitious, we could try to color the wedges by the windspeed. Let&rsquo;s give it a shot!</p><p>We&rsquo;ll need to get the average wind speed in each of our <code>bins</code> from above. This is clearly a <code>groupby</code>, but what excatly is the grouper? This is where pandas <code>Catagorical</code> comes in handy. We&rsquo;ll <a href=http://pandas.pydata.org/pandas-docs/stable/generated/pandas.cut.html><code>pd.cut</code></a> the wind direction, and group the wind data by that.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>wind <span style=color:#f92672>=</span> weather[[<span style=color:#e6db74>&#39;windSpeed&#39;</span>, <span style=color:#e6db74>&#39;windBearing&#39;</span>]]<span style=color:#f92672>.</span>dropna()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ct <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>cut(wind<span style=color:#f92672>.</span>windBearing, bins)
</span></span><span style=display:flex><span>speeds <span style=color:#f92672>=</span> wind<span style=color:#f92672>.</span>groupby(ct)[<span style=color:#e6db74>&#39;windSpeed&#39;</span>]<span style=color:#f92672>.</span>mean()
</span></span><span style=display:flex><span>colors <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>cm<span style=color:#f92672>.</span>BuGn(speeds<span style=color:#f92672>.</span>div(speeds<span style=color:#f92672>.</span>max()))
</span></span></code></pre></div><p>I map the speeds to colors with one of matplotlib&rsquo;s colormaps. It expects values in <code>[0, 1]</code>, so
we normalize the speeds by dividing by the maximum.</p><p><code>hist</code> doesn&rsquo;t take a cmap argument, and I couldn&rsquo;t get <code>color</code> to work, so we&rsquo;ll just plot it like before,
and then modify the color of the patches after the fact.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>fig <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>figure()
</span></span><span style=display:flex><span>ax <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplot(polar<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>ax<span style=color:#f92672>.</span>set_theta_zero_location(<span style=color:#e6db74>&#39;N&#39;</span>)
</span></span><span style=display:flex><span>ax<span style=color:#f92672>.</span>set_theta_direction(<span style=color:#e6db74>&#39;clockwise&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bins <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>arange(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>360</span>, <span style=color:#ae81ff>30</span>)
</span></span><span style=display:flex><span>ax<span style=color:#f92672>.</span>hist(np<span style=color:#f92672>.</span>radians(weather<span style=color:#f92672>.</span>windBearing<span style=color:#f92672>.</span>dropna()), bins<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>radians(bins))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> p, color <span style=color:#f92672>in</span> zip(ax<span style=color:#f92672>.</span>patches, colors):
</span></span><span style=display:flex><span>    p<span style=color:#f92672>.</span>set_facecolor(color)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ax<span style=color:#f92672>.</span>set_title(<span style=color:#e6db74>&#34;Direction of Wind Origin&#34;</span>)
</span></span></code></pre></div><p>Colorbars are tricky in matplotlib (at least for me). So I&rsquo;m going to leave it at darker is stronger wind.</p><p>That&rsquo;s all for now. Come back next time for some exploratory analysis, and if we&rsquo;re lucky, some maps!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://tomaugspurger.net/tags/python/>Python</a></li><li><a href=https://tomaugspurger.net/tags/data-science/>Data Science</a></li><li><a href=https://tomaugspurger.net/tags/pandas/>Pandas</a></li><li><a href=https://tomaugspurger.net/tags/practical-pandas/>Practical Pandas</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://tomaugspurger.net/>Tom's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><a rel=me href=https://mastodon.social/@TomAugspurger></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>