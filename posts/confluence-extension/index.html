<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A Confluence of Extension | Tom's Blog</title>
<meta name=keywords content><meta name=description content="This post describes a few protocols taking shape in the scientific Python community. On their own, each is powerful. Together, I think they enable for an explosion of creativity in the community.
Each of the protocols / interfaces we&rsquo;ll consider deal with extending.
NEP-13: NumPy __array_ufunc__ NEP-18: NumPy __array_function__ Pandas Extension types Custom Dask Collections First, a bit of brief background on each.
NEP-13 and NEP-18, each deal with using the NumPy API on non-NumPy ndarray objects."><meta name=author content><link rel=canonical href=https://tomaugspurger.net/posts/confluence-extension/><link crossorigin=anonymous href=/assets/css/stylesheet.ced21e6d3497ee93fed8f8b357448095840179bd510b5ea0e6013078712e6dd1.css integrity="sha256-ztIebTSX7pP+2PizV0SAlYQBeb1RC16g5gEweHEubdE=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://tomaugspurger.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tomaugspurger.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tomaugspurger.net/favicon-32x32.png><link rel=apple-touch-icon href=https://tomaugspurger.net/apple-touch-icon.png><link rel=mask-icon href=https://tomaugspurger.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tomaugspurger.net/posts/confluence-extension/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="A Confluence of Extension"><meta property="og:description" content="This post describes a few protocols taking shape in the scientific Python community. On their own, each is powerful. Together, I think they enable for an explosion of creativity in the community.
Each of the protocols / interfaces we&rsquo;ll consider deal with extending.
NEP-13: NumPy __array_ufunc__ NEP-18: NumPy __array_function__ Pandas Extension types Custom Dask Collections First, a bit of brief background on each.
NEP-13 and NEP-18, each deal with using the NumPy API on non-NumPy ndarray objects."><meta property="og:type" content="article"><meta property="og:url" content="https://tomaugspurger.net/posts/confluence-extension/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-06-18T00:00:00+00:00"><meta property="article:modified_time" content="2019-06-18T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="A Confluence of Extension"><meta name=twitter:description content="This post describes a few protocols taking shape in the scientific Python community. On their own, each is powerful. Together, I think they enable for an explosion of creativity in the community.
Each of the protocols / interfaces we&rsquo;ll consider deal with extending.
NEP-13: NumPy __array_ufunc__ NEP-18: NumPy __array_function__ Pandas Extension types Custom Dask Collections First, a bit of brief background on each.
NEP-13 and NEP-18, each deal with using the NumPy API on non-NumPy ndarray objects."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tomaugspurger.net/posts/"},{"@type":"ListItem","position":2,"name":"A Confluence of Extension","item":"https://tomaugspurger.net/posts/confluence-extension/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A Confluence of Extension","name":"A Confluence of Extension","description":"This post describes a few protocols taking shape in the scientific Python community. On their own, each is powerful. Together, I think they enable for an explosion of creativity in the community.\nEach of the protocols / interfaces we\u0026rsquo;ll consider deal with extending.\nNEP-13: NumPy __array_ufunc__ NEP-18: NumPy __array_function__ Pandas Extension types Custom Dask Collections First, a bit of brief background on each.\nNEP-13 and NEP-18, each deal with using the NumPy API on non-NumPy ndarray objects.","keywords":[],"articleBody":"This post describes a few protocols taking shape in the scientific Python community. On their own, each is powerful. Together, I think they enable for an explosion of creativity in the community.\nEach of the protocols / interfaces we’ll consider deal with extending.\nNEP-13: NumPy __array_ufunc__ NEP-18: NumPy __array_function__ Pandas Extension types Custom Dask Collections First, a bit of brief background on each.\nNEP-13 and NEP-18, each deal with using the NumPy API on non-NumPy ndarray objects. For example, you might want to apply a ufunc like np.log to a Dask array.\n\u003e\u003e\u003e a = da.random.random((10, 10)) \u003e\u003e\u003e np.log(a) dask.array\u003clog, shape=(10, 10), dtype=float64, chunksize=(10, 10)\u003e Prior to NEP-13, dask.array needed it’s own namespace of ufuncs like da.log, since np.log would convert the Dask array to an in-memory NumPy array (probably blowing up your machine’s memory). With __array_ufunc__ library authors and users can all just use NumPy ufuncs, without worrying about the type of the Array object.\nWhile NEP-13 is limited to ufuncs, NEP-18 applies the same idea to most of the NumPy API. With NEP-18, libraries written to deal with NumPy ndarrays may suddenly support any object implementing __array_function__.\nI highly recommend reading this blog post for more on the motivation for __array_function__. Ralph Gommers gave a nice talk on the current state of things at PyData Amsterdam 2019, though this is an active area of development.\nPandas added extension types to allow third-party libraries to solve domain-specific problems in a way that gels nicely with the rest of pandas. For example, cyberpandas handles network data, while geopandas handles geographic data. When both implement extension arrays it’s possible to operate on a dataset with a mixture of geographic and network data in the same DataFrame.\nFinally, Dask defines a Collections Interface so that any object can be a first-class citizen within Dask. This is what ensures XArray’s DataArray and Dataset objects work well with Dask.\nSeries.__array_ufunc__ Now, onto the fun stuff: combining these interfaces across objects and libraries. https://github.com/pandas-dev/pandas/pull/23293 is a pull request adding Series.__array_ufunc__. There are a few subtleties, but the basic idea is that a ufunc applied to a Series should\nUnbox the array (ndarray or extension array) from the Series Apply the ufunc to the Series (honoring the array’s __array_ufunc__ if needed) Rebox the output in a Series (with the original index and name) For example, pandas’ SparseArray implements __array_ufunc__. It works by calling the ufunc twice, once on the sparse values (e.g. the non-zero values), and once on the scalar fill_value. The result is a new SparseArray with the same memory usage. With that PR, we achieve the same thing when operating on a Series containing an ExtensionArray.\n\u003e\u003e\u003e ser = pd.Series(pd.SparseArray([-10, 0, 10] + [0] * 100000)) \u003e\u003e\u003e ser 0 -10 1 0 2 10 3 0 4 0 .. 99998 0 99999 0 100000 0 100001 0 100002 0 Length: 100003, dtype: Sparse[int64, 0] \u003e\u003e\u003e n [20]: np.sign(ser) 0 -1 1 0 2 1 3 0 4 0 .. 99998 0 99999 0 100000 0 100001 0 100002 0 Length: 100003, dtype: Sparse[int64, 0] Previously, that would have converted the SparseArray to a dense NumPy array, blowing up your memory, slowing things down, and giving the incorrect result.\nIPArray.__array_function__ To demonstrate __array_function__, we’ll implement it on IPArray.\ndef __array_function__(self, func, types, args, kwargs): cls = type(self) if not all(issubclass(t, cls) for t in types): return NotImplemented return HANDLED_FUNCTIONS[func](*args, **kwargs) IPArray is pretty domain-specific, so we place ourself down at the bottom priority by returning NotImplemented if there are any types we don’t recognize (we might consider handling Python’s stdlib ipaddres.IPv4Address and ipaddres.IPv6Address objects too).\nAnd then we start implementing the interface. For example, concatenate.\n@implements(np.concatenate) def concatenate(arrays, axis=0, out=None): if axis != 0: raise NotImplementedError(f\"Axis != 0 is not supported. (Got {axis}).\") return IPArray(np.concatenate([array.data for array in arrays])) With this, we can successfully concatenate two IPArrays\n\u003e\u003e\u003e a = cyberpandas.ip_range(4) \u003e\u003e\u003e b = cyberpandas.ip_range(10, 14) \u003e\u003e\u003e np.concatenate([a, b]) IPArray(['0.0.0.0', '0.0.0.1', '0.0.0.2', '0.0.0.3', '0.0.0.10', '0.0.0.11', '0.0.0.12', '0.0.0.13']) Extending Dask Finally, we may wish to make IPArray work well with dask.dataframe, to do normal cyberpandas operations in parallel, possibly distributed on a cluster. This requires a few changes:\nUpdating IPArray to work on either NumPy or Dask arrays Implementing the Dask Collections interface on IPArray. Registering an ip accessor with dask.dataframe, just like with pandas. This is demonstrated in https://github.com/ContinuumIO/cyberpandas/pull/39\nIn [28]: ddf Out[28]: Dask DataFrame Structure: A npartitions=2 0 ip 6 ... 11 ... Dask Name: from_pandas, 2 tasks In [29]: ddf.A.ip.netmask() Out[29]: Dask Series Structure: npartitions=2 0 ip 6 ... 11 ... Name: A, dtype: ip Dask Name: from-delayed, 22 tasks In [30]: ddf.A.ip.netmask().compute() Out[30]: 0 255.255.255.255 1 255.255.255.255 2 255.255.255.255 3 255.255.255.255 4 255.255.255.255 5 255.255.255.255 6 255.255.255.255 7 255.255.255.255 8 255.255.255.255 9 255.255.255.255 10 255.255.255.255 11 255.255.255.255 dtype: ip Conclusion I think that these points of extension.\n","wordCount":"805","inLanguage":"en","datePublished":"2019-06-18T00:00:00Z","dateModified":"2019-06-18T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://tomaugspurger.net/posts/confluence-extension/"},"publisher":{"@type":"Organization","name":"Tom's Blog","logo":{"@type":"ImageObject","url":"https://tomaugspurger.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tomaugspurger.net/ accesskey=h title="Tom's Blog (Alt + H)">Tom's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://tomaugspurger.net/about/ title=About><span>About</span></a></li><li><a href=https://tomaugspurger.net/archives title=Archive><span>Archive</span></a></li><li><a href=https://tomaugspurger.net/index.xml title=RSS><span>RSS</span></a></li><li><a href=https://tomaugspurger.net/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">A Confluence of Extension</h1><div class=post-meta><span title='2019-06-18 00:00:00 +0000 UTC'>June 18, 2019</span></div></header><div class=post-content><p>This post describes a few protocols taking shape in the scientific Python
community. On their own, each is powerful. Together, I think they enable for an
explosion of creativity in the community.</p><p>Each of the protocols / interfaces we&rsquo;ll consider deal with extending.</p><ul><li><a href=https://www.numpy.org/neps/nep-0013-ufunc-overrides.html>NEP-13: NumPy <code>__array_ufunc__</code></a></li><li><a href=https://www.numpy.org/neps/nep-0018-array-function-protocol.html>NEP-18: NumPy <code>__array_function__</code></a></li><li><a href=http://pandas.pydata.org/pandas-docs/stable/development/extending.html#extension-types>Pandas Extension types</a></li><li><a href=https://docs.dask.org/en/latest/custom-collections.html>Custom Dask Collections</a></li></ul><hr><p>First, a bit of brief background on each.</p><p>NEP-13 and NEP-18, each deal with using the NumPy API on non-NumPy ndarray
objects. For example, you might want to apply a ufunc like <code>np.log</code> to a Dask
array.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> a <span style=color:#f92672>=</span> da<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>random((<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>))
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> np<span style=color:#f92672>.</span>log(a)
</span></span><span style=display:flex><span>dask<span style=color:#f92672>.</span>array<span style=color:#f92672>&lt;</span>log, shape<span style=color:#f92672>=</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>), dtype<span style=color:#f92672>=</span>float64, chunksize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>)<span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>Prior to NEP-13, <code>dask.array</code> needed it&rsquo;s own namespace of ufuncs like <code>da.log</code>,
since <code>np.log</code> would convert the Dask array to an in-memory NumPy array
(probably blowing up your machine&rsquo;s memory). With <code>__array_ufunc__</code> library
authors and users can all just use NumPy ufuncs, without worrying about the type of
the Array object.</p><p>While NEP-13 is limited to ufuncs, NEP-18 applies the same idea to most of the
NumPy API. With NEP-18, libraries written to deal with NumPy ndarrays may
suddenly support any object implementing <code>__array_function__</code>.</p><p>I highly recommend reading <a href=https://blog.dask.org/2018/05/27/beyond-numpy>this blog
post</a> for more on the motivation
for <code>__array_function__</code>. Ralph Gommers gave a nice talk on the current state of
things at <a href=https://youtu.be/HVLPJnvInzM>PyData Amsterdam 2019</a>, though this is
an active area of development.</p><p>Pandas added extension types to allow third-party libraries to solve
domain-specific problems in a way that gels nicely with the rest of pandas. For
example, cyberpandas handles network data, while geopandas handles geographic
data. When both implement extension arrays it&rsquo;s possible to operate on a dataset
with a mixture of geographic and network data in the same DataFrame.</p><p>Finally, Dask defines a <a href=https://docs.dask.org/en/latest/custom-collections.html>Collections Interface</a> so that any
object can be a first-class citizen within Dask. This is what ensures <a href=http://xarray.pydata.org/>XArray&rsquo;s</a>
DataArray and Dataset objects work well with Dask.</p><h2 id=series__array_ufunc__><code>Series.__array_ufunc__</code><a hidden class=anchor aria-hidden=true href=#series__array_ufunc__>#</a></h2><p>Now, onto the fun stuff: combining these interfaces across objects and
libraries. <a href=https://github.com/pandas-dev/pandas/pull/23293>https://github.com/pandas-dev/pandas/pull/23293</a> is a pull request
adding <code>Series.__array_ufunc__</code>. There are a few subtleties, but the basic idea
is that a ufunc applied to a Series should</p><ol><li>Unbox the array (ndarray or extension array) from the Series</li><li>Apply the ufunc to the Series (honoring the array&rsquo;s <code>__array_ufunc__</code> if
needed)</li><li>Rebox the output in a Series (with the original index and name)</li></ol><p>For example, pandas&rsquo; <code>SparseArray</code> implements <code>__array_ufunc__</code>. It works by
calling the ufunc twice, once on the sparse values (e.g. the non-zero values),
and once on the scalar <code>fill_value</code>. The result is a new <code>SparseArray</code> with the
same memory usage. With that PR, we achieve the same thing when operating on a
Series containing an ExtensionArray.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> ser <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>Series(pd<span style=color:#f92672>.</span>SparseArray([<span style=color:#f92672>-</span><span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>10</span>] <span style=color:#f92672>+</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>100000</span>))
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> ser
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>        <span style=color:#f92672>-</span><span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>          <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>         <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>          <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>          <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>99998</span>      <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>99999</span>      <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>100000</span>     <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>100001</span>     <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>100002</span>     <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>Length: <span style=color:#ae81ff>100003</span>, dtype: Sparse[int64, <span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> n [<span style=color:#ae81ff>20</span>]: np<span style=color:#f92672>.</span>sign(ser)
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>        <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>         <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>         <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>         <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>         <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>         <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>99998</span>     <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>99999</span>     <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>100000</span>    <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>100001</span>    <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>100002</span>    <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>Length: <span style=color:#ae81ff>100003</span>, dtype: Sparse[int64, <span style=color:#ae81ff>0</span>]
</span></span></code></pre></div><p>Previously, that would have converted the <code>SparseArray</code> to a <em>dense</em> NumPy
array, blowing up your memory, slowing things down, and giving the incorrect result.</p><h2 id=iparray__array_function__><code>IPArray.__array_function__</code><a hidden class=anchor aria-hidden=true href=#iparray__array_function__>#</a></h2><p>To demonstrate <code>__array_function__</code>, we&rsquo;ll implement it on <code>IPArray</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__array_function__</span>(self, func, types, args, kwargs):
</span></span><span style=display:flex><span>        cls <span style=color:#f92672>=</span> type(self)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> all(issubclass(t, cls) <span style=color:#66d9ef>for</span> t <span style=color:#f92672>in</span> types):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> NotImplemented
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> HANDLED_FUNCTIONS[func](<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs)
</span></span></code></pre></div><p><code>IPArray</code> is pretty domain-specific, so we place ourself down at the bottom
priority by returning <code>NotImplemented</code> if there are any types we don&rsquo;t recognize
(we might consider handling Python&rsquo;s stdlib <code>ipaddres.IPv4Address</code> and
<code>ipaddres.IPv6Address</code> objects too).</p><p>And then we start implementing the interface. For example, <code>concatenate</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@implements</span>(np<span style=color:#f92672>.</span>concatenate)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>concatenate</span>(arrays, axis<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, out<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> axis <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>NotImplementedError</span>(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Axis != 0 is not supported. (Got </span><span style=color:#e6db74>{</span>axis<span style=color:#e6db74>}</span><span style=color:#e6db74>).&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> IPArray(np<span style=color:#f92672>.</span>concatenate([array<span style=color:#f92672>.</span>data <span style=color:#66d9ef>for</span> array <span style=color:#f92672>in</span> arrays]))
</span></span></code></pre></div><p>With this, we can successfully concatenate two IPArrays</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> a <span style=color:#f92672>=</span> cyberpandas<span style=color:#f92672>.</span>ip_range(<span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> b <span style=color:#f92672>=</span> cyberpandas<span style=color:#f92672>.</span>ip_range(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>14</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> np<span style=color:#f92672>.</span>concatenate([a, b])
</span></span><span style=display:flex><span>IPArray([<span style=color:#e6db74>&#39;0.0.0.0&#39;</span>, <span style=color:#e6db74>&#39;0.0.0.1&#39;</span>, <span style=color:#e6db74>&#39;0.0.0.2&#39;</span>, <span style=color:#e6db74>&#39;0.0.0.3&#39;</span>, <span style=color:#e6db74>&#39;0.0.0.10&#39;</span>, <span style=color:#e6db74>&#39;0.0.0.11&#39;</span>, <span style=color:#e6db74>&#39;0.0.0.12&#39;</span>, <span style=color:#e6db74>&#39;0.0.0.13&#39;</span>])
</span></span></code></pre></div><h2 id=extending-dask>Extending Dask<a hidden class=anchor aria-hidden=true href=#extending-dask>#</a></h2><p>Finally, we may wish to make <code>IPArray</code> work well with <code>dask.dataframe</code>, to do
normal cyberpandas operations in parallel, possibly distributed on a cluster.
This requires a few changes:</p><ol><li>Updating <code>IPArray</code> to work on either NumPy or Dask arrays</li><li>Implementing the Dask Collections interface on <code>IPArray</code>.</li><li>Registering an <code>ip</code> accessor with <code>dask.dataframe</code>, just like with <code>pandas</code>.</li></ol><p>This is demonstrated in <a href=https://github.com/ContinuumIO/cyberpandas/pull/39>https://github.com/ContinuumIO/cyberpandas/pull/39</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>In [<span style=color:#ae81ff>28</span>]: ddf
</span></span><span style=display:flex><span>Out[<span style=color:#ae81ff>28</span>]:
</span></span><span style=display:flex><span>Dask DataFrame Structure:
</span></span><span style=display:flex><span>                 A
</span></span><span style=display:flex><span>npartitions<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>               ip
</span></span><span style=display:flex><span><span style=color:#ae81ff>6</span>              <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>11</span>             <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>Dask Name: from_pandas, <span style=color:#ae81ff>2</span> tasks
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>29</span>]: ddf<span style=color:#f92672>.</span>A<span style=color:#f92672>.</span>ip<span style=color:#f92672>.</span>netmask()
</span></span><span style=display:flex><span>Out[<span style=color:#ae81ff>29</span>]:
</span></span><span style=display:flex><span>Dask Series Structure:
</span></span><span style=display:flex><span>npartitions<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>      ip
</span></span><span style=display:flex><span><span style=color:#ae81ff>6</span>     <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>11</span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>Name: A, dtype: ip
</span></span><span style=display:flex><span>Dask Name: from<span style=color:#f92672>-</span>delayed, <span style=color:#ae81ff>22</span> tasks
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>In [<span style=color:#ae81ff>30</span>]: ddf<span style=color:#f92672>.</span>A<span style=color:#f92672>.</span>ip<span style=color:#f92672>.</span>netmask()<span style=color:#f92672>.</span>compute()
</span></span><span style=display:flex><span>Out[<span style=color:#ae81ff>30</span>]:
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>     <span style=color:#ae81ff>255.255.255.255</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>     <span style=color:#ae81ff>255.255.255.255</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>     <span style=color:#ae81ff>255.255.255.255</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>     <span style=color:#ae81ff>255.255.255.255</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>     <span style=color:#ae81ff>255.255.255.255</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>5</span>     <span style=color:#ae81ff>255.255.255.255</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>6</span>     <span style=color:#ae81ff>255.255.255.255</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span>     <span style=color:#ae81ff>255.255.255.255</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>8</span>     <span style=color:#ae81ff>255.255.255.255</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>9</span>     <span style=color:#ae81ff>255.255.255.255</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>10</span>    <span style=color:#ae81ff>255.255.255.255</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>11</span>    <span style=color:#ae81ff>255.255.255.255</span>
</span></span><span style=display:flex><span>dtype: ip
</span></span></code></pre></div><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>I think that these points of extension.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://tomaugspurger.net/>Tom's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><a rel=me href=https://mastodon.social/@TomAugspurger></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>