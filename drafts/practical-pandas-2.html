<!DOCTYPE html>
<html lang="en">
<head>
          <title>DatasFrame</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
        <link rel="stylesheet" href="../theme/css/main.css" />
        <script src="//code.jquery.com/jquery-2.2.2.min.js"></script>




</head>

<body id="index" class="home">
    <nav>
      <a href="..">Home | </a>
      <a href="/archives.html">Archive | </a>
      <a href="/categories.html">Categories | </a>
      <a href="/pages/about.html">About | </a>
      <a href="https://tomaugspurger.github.io/feeds/all.rss.xml">RSS</a>
    </nav>

<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="../drafts/practical-pandas-2.html" rel="bookmark"
         title="Permalink to Practical Pandas--Part 2">Practical Pandas--Part 2</a></h2>
 
  </header>
  <footer class="post-info">
    <abbr class="published" title="2015-01-01T00:00:00-06:00">
      Thu 01 January 2015
    </abbr>
    <address class="vcard author">
      By           <a class="url fn" href="../author/tom-augspurger.html">Tom Augspurger</a>
    </address>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p><em>This is Part 2 in my Practical Pandas Series, where I work through a data analysis problem from start to finish.</em></p>
<p>It's a misconception that we can cleanly separate the data analysis pipeline into a linear
sequence of steps from</p>
<ol>
<li>data acquisition</li>
<li>data tidying</li>
<li>exploratory analysis</li>
<li>model building</li>
<li>production</li>
</ol>
<p>As you work through a problem you'll realize, "I need this other bit of data", or "this would be easier if I stored the data this way", or more commonly "strange, that's not supposed to happen".</p>
<p>We'll follow up our <a href="http://tomaugspurger.github.io/blog/2014/08/26/practical-pandas-part-1-reading-the-data/">last post</a> by circling back to cleaning up our data set, and fetching some more data.
Here's a reminder of where we were.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="kn">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_hdf</span><span class="p">(</span><span class="s1">&#39;data/cycle_store.h5&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;merged&#39;</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>


<p>Because of a <a href="https://github.com/pydata/pandas/issues/8189">bug</a> in pandas, we lost our timzone information when we filled in our missing values. Until that's fixed we'll have to manually add back the timezone info and convert.</p>
<p>I like to keep my DataFrame columns as valid python identifiers.
Let's define a helper function to rename the columns. We also have a few redundant columns that we can drop.</p>
<div class="codehilite"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;Ride Time&#39;</span><span class="p">,</span> <span class="s1">&#39;Stopped Time&#39;</span><span class="p">,</span> <span class="s1">&#39;Pace&#39;</span><span class="p">,</span> <span class="s1">&#39;Average Pace&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">renamer</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="s1">&#39;)&#39;</span><span class="p">]:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">name</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">renamer</span><span class="p">)</span>
<span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
</pre></div>


<h3>Do you trust the data?</h3>
<p>Remember that I needed to manually start and stop the timer each ride, which natuarlly means that I messed this up at least once. Let's see if we can figure out the rides where I messed things up.
The first heuristic we'll use is checking to see if I moved at all.</p>
<p>All of my rides should have take roughly the same about of time. Let's get an idea of how the distribution of ride times look. We'll look at both the ride time and the time I spent stopped.
If I spend a long time in the same place, there's a good chance that I finished my ride and forgot to stop the timer.</p>
<div class="codehilite"><pre><span></span><span class="n">time_pal</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="n">n_colors</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Plot it in mintues</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="c1"># max to get the last observation per ride since we know these are increasing</span>
<span class="n">times</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;ride_id&#39;</span><span class="p">)[[</span><span class="s1">&#39;stopped_time_secs&#39;</span><span class="p">,</span> <span class="s1">&#39;ride_time_secs&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">times</span><span class="p">[</span><span class="s1">&#39;ride_time_secs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">time_pal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Ride Time&quot;</span><span class="p">)</span>

<span class="n">times</span><span class="p">[</span><span class="s1">&#39;stopped_time_secs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">time_pal</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Stopped Time&quot;</span><span class="p">);</span>
</pre></div>


<p>Let's dig into that spike in the stopped time. We'll get it's ride id with the <code>Series.argmax</code> method.</p>
<div class="codehilite"><pre><span></span><span class="n">idx</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">stopped_time_secs</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
<span class="n">long_stop</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">ride_id</span> <span class="o">==</span> <span class="n">idx</span><span class="p">]</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">long_stop</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)[</span><span class="s1">&#39;distance_miles&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">avg_distance</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;ride_id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">distance_miles</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Distance (miles)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">avg_distance</span><span class="p">,</span> <span class="o">*</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">());</span>
</pre></div>


<p>So it looks like I started my timer, sat around for about 15 minutes, and then continued with my normal ride (I verified that by plotting the average distance travelled per ride, and it was right on target).</p>
<p>We can use most of the columns fine, it's just the the <code>time</code> column we need to be careful with. Let's
make an adjusted time column <code>time_adj</code> that accounts for the stopped time.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">datetime</span>

<span class="k">def</span> <span class="nf">as_timedelta</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">//</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">df</span><span class="p">[</span><span class="s1">&#39;time_adj&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">time</span> <span class="o">-</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">stopped_time_secs</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>


<p>When we start using the actual GPS data, we may need to do some smoothing.
These are just readings from my iPhone, which probably aren't that accurate. <a href="http://en.wikipedia.org/wiki/Kalman_filter">Kalman filters</a>, which I learned about in my econometrics class, are commonly used for this purpose.
But I think that's good enough for now. </p>
<h3>Getting More Data</h3>
<p>I'm interested in explaining the variation in how long it took me to make the ride.
I hypothesize that the weather may have had something to do with it. We'll fetch data from <a href="http://forecast.io">forecas.io</a> using their <a href="https://developer.forecast.io">API</a> to get the weather conditions at the time of each ride.</p>
<p>I looked at the <a href="https://developer.forecast.io/docs/v2">forecast.io documentation</a>, and noticed that the API will require a timezone. We could proceed in two ways</p>
<ol>
<li>Set <code>df.time</code> to be the index (a DatetimeIndex). Then localize with <code>df.tz_localize</code></li>
<li>Pass <code>df.time</code> through the DatetimeIndex constructor to set the timezone, and set that to be a column in df.</li>
</ol>
<p>Ideally we'd go with 1. Pandas has a lot of great additoinal functionality to offer when you have a DatetimeIndex (such as <code>resample</code>).
However, this conflicts with the desire to have a unique index with this specific dataset. The times recorded are at the second frequency, but there are occasionally multiple readings in a second.</p>
<div class="codehilite"><pre><span></span><span class="c1"># should be 0 if there are no repeats.</span>
<span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
</pre></div>


<p>So we'll go with #2, running the <code>time</code> column through the <code>DatetimeIndex</code> constructor, which has a <code>tz</code> (timezone) parameter, and placing that in a 'time' column. I'm in the <code>US/Central</code> timezone.</p>
<div class="codehilite"><pre><span></span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="s1">&#39;US/Central&#39;</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>


<p>There's nothing specific to pandas here, but knowing the basics of calling an API and parsing the response is still useful.
We'll use <a href="http://docs.python-requests.org/en/latest/">requests</a> to make the
API call. You'll need to register for you own API key. I keep mine in a JSON file in my Dropbox bin folder.</p>
<p>For this specific call we need to give the Latitude, Longitude, and Time that we want the weather for.
We fill in those to a url with the format <code>https://api.forecast.io/forecast/{key}/{Latitude},{Longitude},{Time}</code>.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">requests</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~/Dropbox/bin/api-keys.txt&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)[</span><span class="s1">&#39;forecast.io&#39;</span><span class="p">]</span>

<span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;https://api.forecast.io/forecast/{key}/{Latitude},{Longitude},{Time}&quot;</span>

<span class="n">vals</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">title</span><span class="p">())</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
<span class="n">vals</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="n">vals</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">vals</span><span class="p">))</span>
<span class="n">resp</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="n">resp</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</pre></div>


<p>Here's the plan. For each ride, we'll get the current conditions at the time, latitude, and longitude of departure.
We'll use those values for the entirety of that ride.</p>
<p>I'm a bit concerned about the variance of some quantities from the weather data (like the windspeed and bearing). This would be something to look into for a serious analysis. If the quantities are highly variable you would want to take a rolling average over more datapoints. <code>forecast.io</code> limits you to 1,000 API calls per day though (at the free tier), so we'll just stick with one request per ride.</p>
<p>We'll also cache the results.</p>
<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_weather</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">ride_id</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the current weather conditions for for a ride at the time of departure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;https://api.forecast.io/forecast/{key}/{Latitude},{Longitude},{Time}&quot;</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;ride_id == @ride_id&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][[</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span>
               <span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">title</span><span class="p">())</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    <span class="n">vals</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
    <span class="n">vals</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">vals</span><span class="p">))</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">json</span><span class="p">()[</span><span class="s1">&#39;currently&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">resp</span>

<span class="k">def</span> <span class="nf">weather_series</span><span class="p">(</span><span class="n">ride_ids</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="s1">&#39;data/weather.json&#39;</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_weather</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">ride_id</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">ride_id</span>
                <span class="ow">in</span> <span class="n">ride_ids</span><span class="p">]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>


<p>Let's test it out:</p>
<div class="codehilite"><pre><span></span><span class="n">get_weather</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">ride_id</span><span class="o">.</span><span class="n">unique</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>
</pre></div>


<p>Now do that for each <code>ride_id</code>, and store the result in a DataFrame</p>
<p>```{ python }
conditions = weather_series(df.ride_id.unique())
weather = pd.DataFrame(conditions)
weather.head()</p>
<div class="codehilite"><pre><span></span>Let&#39;s fixup the dtype on the `time` column. We need to convert from the seconds to a datetime.
Then handle the timezone like before. This is returned in &#39;UTC&#39;, so we&#39;ll bring it back to
my local time with `.tz_convert`.


```{python}
weather[&#39;time&#39;] = (pd.DatetimeIndex(pd.to_datetime(weather.time, unit=&#39;s&#39;))
                     .tz_localize(&#39;UTC&#39;).tz_convert(&#39;US/Central&#39;))
</pre></div>


<div class="codehilite"><pre><span></span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">time</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>


<p>Now we can merge the two DataFrames <code>weather</code> and <code>df</code>. In this case it's quite simple since the share a single column, <code>time</code>. Pandas behaves exactly as you'd expect, merging on the provided column.
We take the <code>outer</code> join since we only have weather information for the first observation of each ride.
We'll fill those values forward for the entirety of the ride.</p>
<p>I don't just call <code>with_weather.fillna()</code> since the non-weather columns have <code>NaN</code>s that we may want to treat separately.</p>
<div class="codehilite"><pre><span></span><span class="n">with_weather</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">weather</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">with_weather</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">with_weather</span><span class="p">[</span><span class="n">weather</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">with_weather</span><span class="p">[</span><span class="n">weather</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;ffill&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">with_weather</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="n">with_weather</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>


<p>With that done, let's write <code>with_weather</code> out to disk. We'll get a Performance Warning since some of the columns are text, which are relatively slow for HDF5, but it's not a problem worth worrying about for a dataset this small.
If you needed you could encode the text ones as integers with <code>pd.factorize</code>, write the integers out the HDF5 store, and store the mapping from integer to text description elsewhere.</p>
<div class="codehilite"><pre><span></span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">weather</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;coerce&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="n">weather</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">weather</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">utc</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">with_weather</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">with_weather</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">utc</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="n">with_weather</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="s1">&#39;data/cycle_store.h5&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;with_weather&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s1">&#39;table&#39;</span><span class="p">)</span>
<span class="n">weather</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="s1">&#39;data/cycle_store.h5&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;weather&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s1">&#39;table&#39;</span><span class="p">)</span>
</pre></div>


<h3>A bit of Exploring</h3>
<p>We've done a lot of data wrangling with a notable lack of pretty pictures to look at. Let's fix that.</p>
<div class="codehilite"><pre><span></span><span class="n">sns</span><span class="o">.</span><span class="n">puppyplot</span><span class="p">()</span>
</pre></div>


<p>For some other (less) pretty pictures, let's visualize some of the weather data we collected.</p>
<div class="codehilite"><pre><span></span><span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">)</span>

<span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">,</span> <span class="s1">&#39;apparentTemperature&#39;</span><span class="p">,</span> <span class="s1">&#39;humidity&#39;</span><span class="p">,</span> <span class="s1">&#39;dewPoint&#39;</span><span class="p">,</span> <span class="s1">&#39;pressure&#39;</span><span class="p">]</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">PairGrid</span><span class="p">(</span><span class="n">weather</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()[</span><span class="n">cols</span><span class="p">])</span>

<span class="n">g</span><span class="o">.</span><span class="n">map_diag</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">map_lower</span><span class="p">(</span><span class="n">sns</span><span class="o">.</span><span class="n">kdeplot</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;Blues_d&quot;</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">map_upper</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">);</span>
</pre></div>


<p>Not bad! <a href="http://web.stanford.edu/~mwaskom/software/seaborn/">Seaborn</a> makes exploring these relationships very easy.</p>
<p>Let's also take a look at the wind data. I'm not a meteorologist, but I saw a plot one time that's like a histogram for wind directions, but plotted on a <a href="http://en.wikipedia.org/wiki/Polar_coordinate_system">polar axis</a> (brings back memories of Calc II). Fortunately for us, matplotlib handles polar plots pretty easily, we just have to setup the
axes and hand it the values as radians.</p>
<div class="codehilite"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">polar</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_theta_zero_location</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_theta_direction</span><span class="p">(</span><span class="s1">&#39;clockwise&#39;</span><span class="p">)</span>

<span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">361</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">weather</span><span class="o">.</span><span class="n">windBearing</span><span class="o">.</span><span class="n">dropna</span><span class="p">()),</span> <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">bins</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Direction of Wind Origin&quot;</span><span class="p">);</span>
</pre></div>


<p><code>windBearing</code> represent the direction the wind is coming <em>from</em> so the most common direction is from the S/SW. It may be clearer to flip that around to represent the wind direction; I'm not sure what's standard.</p>
<p>If we were feeling ambitious, we could try to color the wedges by the windspeed. Let's give it a shot!</p>
<p>We'll need to get the average wind speed in each of our <code>bins</code> from above. This is clearly a <code>groupby</code>, but what exactly is the grouper? This is where pandas <code>Catagorical</code> comes in handy. We'll <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.cut.html"><code>pd.cut</code></a> the wind direction, and group the wind data by that.</p>
<div class="codehilite"><pre><span></span><span class="n">wind</span> <span class="o">=</span> <span class="n">weather</span><span class="p">[[</span><span class="s1">&#39;windSpeed&#39;</span><span class="p">,</span> <span class="s1">&#39;windBearing&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>

<span class="n">ct</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">wind</span><span class="o">.</span><span class="n">windBearing</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
<span class="n">speeds</span> <span class="o">=</span> <span class="n">wind</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">ct</span><span class="p">)[</span><span class="s1">&#39;windSpeed&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">BuGn</span><span class="p">(</span><span class="n">speeds</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">speeds</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
</pre></div>


<p>I map the speeds to colors with one of matplotlib's colormaps. It expects values in <code>[0, 1]</code>, so
we normalize the speeds by dividing by the maximum.</p>
<p><code>hist</code> doesn't take a cmap argument, and I couldn't get <code>color</code> to work, so we'll just plot it like before,
and then modify the color of the patches after the fact.</p>
<div class="codehilite"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">polar</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_theta_zero_location</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_theta_direction</span><span class="p">(</span><span class="s1">&#39;clockwise&#39;</span><span class="p">)</span>

<span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">weather</span><span class="o">.</span><span class="n">windBearing</span><span class="o">.</span><span class="n">dropna</span><span class="p">()),</span> <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">bins</span><span class="p">))</span>

<span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">patches</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Direction of Wind Origin&quot;</span><span class="p">);</span>
</pre></div>


<p>Colorbars are tricky in matplotlib (at least for me). So I'm going to leave it at darker is stronger wind.</p>
<p>That's all for now. Come back next time for some exploratory analysis, and if we're lucky, some maps!</p>
  </div><!-- /.entry-content -->
</section>

    <footer>
      <p>&copy; Tom Augspurger </p>
    </footer>
  </main>

</body>
</html>