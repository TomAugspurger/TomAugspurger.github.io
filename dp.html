<!DOCTYPE html>
<html lang="en">
<head>
          <title>DatasFrame</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
        <link rel="stylesheet" href="./theme/css/main.css" />
        <script src="//code.jquery.com/jquery-2.2.2.min.js"></script>




</head>

<body id="index" class="home">
    <nav>
      <a href=".">Home | </a>
      <a href="/archives.html">Archive | </a>
      <a href="/categories.html">Categories | </a>
      <a href="/pages/about.html">About | </a>
      <a href="https://tomaugspurger.github.io/feeds/all.rss.xml">RSS</a>
    </nav>

<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="./dp.html" rel="bookmark"
         title="Permalink to Dynamic Programming">Dynamic Programming</a></h2>
 
  </header>
  <footer class="post-info">
    <abbr class="published" title="2015-10-03T00:00:00-05:00">
      Sat 03 October 2015
    </abbr>
    <address class="vcard author">
      By           <a class="url fn" href="./author/tom-augspurger.html">Tom Augspurger</a>
    </address>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p>Eight months ago, Trey Causey wrote a <a href="http://thespread.us/expected-points.html">post</a> about modeling expected points in football, with an emphasis on uncertainty.
With my twisted economist's mind, I mentioned that it seemed like dynamic programming could be used in this situation, and indeed it would feature in a future post of Trey's.
From that point the "race" was on to see who would blog about it first.</p>
<p>Dynamic programming<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup> is useful for solving a certain class of problems, but my real motivation for writing this up is because it's such a neat technique.</p>
<p>In brief, Dynamic programming is an optimization method that splits complicated problems into smaller subproblems.
The solutions to the small subproblems turn out to be the solution to the larger problem.
There are proofs for this claim, but we'll mostly take those for granted and focus on the technique.</p>
<h2>An Example</h2>
<p>Given my background in economics, I don't really have a choice here;
our motivating example will be a consumer trying to figure out how to allocate his capital.
We'll setup the problem more formally below, but the basic problem involves choosing the best <em>infinite</em> sequence of consumption, subject to some feasibility constraints.
The solution balances the reward of consumption today against investment for greater consumption in the future.
Solving for the best infinite sequence directly is generally intractable.
Instead, we'll use dynamic programming to break the infinite-sequence problem down to a simple two-period problem.</p>
<p>There's quite a bit of setup before we can get to the actual application, but hold on to that intuition from above: our solution will balance that tradeoff between consumption today and consumption in the future.
Lock it away and keep it safe, I'll let you know when you can take it out again.</p>
<h2>The Setup</h2>
<p>We'll use the notation (and pieces of the code) from Sargent &amp; Stachurski's <a href="http://quant-econ.net/">Quantitative Economics</a>.
Let's also import a few things right away.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="kn">as</span> <span class="nn">sns</span>
<span class="n">sns</span><span class="o">.</span><span class="n">set_style</span><span class="p">(</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
</pre></div>


<p>Imagine you're an infinitely lived agent, and at time <span class="math">\(t\)</span> you own some positive amount of capital, <span class="math">\(k_t\)</span>.
Capital can be used for two things</p>
<ol>
<li>consumption: <span class="math">\(c_t\)</span></li>
<li>production: <span class="math">\(y_t = f(k_t)\)</span></li>
</ol>
<h2>Production</h2>
<p>There are two (intertwined) sides to this problem, production and consumption.
We'll start with production, and assume that the production function, <span class="math">\(f\)</span>, has decreasing returns to scale.
Cobb-Douglas is the typical form for <span class="math">\(f\)</span>: <span class="math">\(f(\cdot) = AK^{\alpha}\)</span> where <span class="math">\(A\)</span> is some positive constant (say 1) and <span class="math">\(\alpha &lt; 1\)</span> for decreasing returns to scale.</p>
<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="err">α</span><span class="o">=.</span><span class="mi">65</span><span class="p">):</span>
    <span class="s2">&quot;Cobb-Douglas Production Function&quot;</span>
    <span class="k">return</span> <span class="n">A</span> <span class="o">*</span> <span class="n">k</span> <span class="o">**</span> <span class="err">α</span>


<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">.</span><span class="mo">01</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Production Function&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Capital: $k_t$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Output: $y_t$&quot;</span><span class="p">)</span>
<span class="n">sns</span><span class="o">.</span><span class="n">despine</span><span class="p">()</span>
</pre></div>


<p><img alt="Production Function" src="./images/dp_production_function.svg" /></p>
<p>We also have our <em>law of motion</em> for capital:</p>
<div class="math">\begin{equation}
    k_{t+1} = y_t - c_t = f(k_t) - c_t
\end{equation}</div>
<p>This tells us how our capital stock evolves from period to period.</p>
<p>That covers the production side, now for consumption.</p>
<h2>Consumption</h2>
<p>We'll need one more building block before we can state the problem: a utility function.
There are two aspects to a utility function:</p>
<ol>
<li><span class="math">\(u(c_t)\)</span>: your instantaneous utility function. We'll use <span class="math">\(u(\cdot) = \ln(\cdot)\)</span></li>
<li><span class="math">\(U(\{c\}_{t=0}^{\infty})\)</span>, your lifetime utility function. We'll use <span class="math">\(\sum_{t=0}^{\infty} \beta^t u(c_t)\)</span></li>
</ol>
<p><span class="math">\(\beta\)</span> is a <em>discount factor</em>, assumed to be less than 1 (say .95).
This reflects a preference for one unit of consumption today rather than tomorrow and is part of why interest rates are (typically) positive.
We want to maximize our lifetime utility, which represent how happy some <em>infinite</em> sequence of consumption <span class="math">\(\{c_t\}_{t=0}^{\infty}\)</span>
Stated formally:</p>
<div class="math">\begin{equation}
\begin{aligned}
  &amp; \max_{\{c_t\}_{t=0}^{\infty}}
  &amp; &amp; \sum_{t=0}^{\infty} \beta^t u(c_t) \\
  &amp; \text{subject to}
  &amp; &amp; c_t + k_t \leq y_t \\
  &amp;&amp;&amp; k_{t+1} = f(k_t) + c_t \\
  &amp;&amp;&amp; c_t, k_t \geq 0 \; \forall \; t \\
\end{aligned}
\end{equation}</div>
<p>We've already seen all the pieces here, but let's still break it down.
Our choice here is the in <em>infinite</em> sequence <span class="math">\(c_t, c_{t+1}, c_{t+2}, \ldots\)</span>.
We get utility <span class="math">\(u(c_t)\)</span> from consumption today, plus <span class="math">\(\beta u(c_{t+1})\)</span> tomorrow, and <span class="math">\(\beta^2 u(c_{t+2})\)</span> after that, <span class="math">\(\ldots\)</span>.</p>
<p>We've got the resource constraint from before, and the law of motion for capital.
I also threw on some non-negativity constraints, but those are just a formality.</p>
<p>Stepping back, let's appreciate how difficult this problem is.
We're being asked to chose an infinite sequence.
It turns out that there are <em>a lot</em> of possible infinite sequences (say, an infinite number), and we need to find the one that does best.
This is where dynamic programming comes in.</p>
<p>Thanks to how carefully we've constructed our problem (read: assumed away difficulties), we've got a nice time invariance property.
We can prove, perhaps in a follow-up post, that any solution must only depend on the level of <span class="math">\(k_t\)</span>, and <em>not</em> on time <span class="math">\(t\)</span>. That is, there exists a <strong>policy function</strong> <span class="math">\(\sigma\)</span> such that</p>
<div class="math">\begin{equation}
c_t = \sigma(k_t) \; \forall \; t
\end{equation}</div>
<p>It's that <em>for all</em> <span class="math">\(t\)</span> at the end there that's important.
To reword that one more way, it doesn't matter how you got to where you are today (with capital <span class="math">\(k_t\)</span>).
All that matters is the level.
Once you find that optimal policy function <span class="math">\(\sigma\)</span>, just follow that forever and you'll attain optimal utility.</p>
<p>All this work has been to construct a <em>state variable</em> that entirely summarizes our situation.
Well, <span class="math">\(k_t\)</span> is that variable.
Behold:</p>
<div class="math">\begin{equation}
\max_{\sigma \in \Sigma}  \sum_{t=0}^{\infty} \beta^t u(\sigma(k_t))
\end{equation}</div>
<p><span class="math">\(\Sigma\)</span> is the set of all feasible policy functions (satisfy the resource and non-negativity constraints and the law of motion for capital).
Our problem is to find the <em>function</em> <span class="math">\(\sigma\)</span> that maximizes this infinite sequence.
As a (non-optimal) example, it could be that <span class="math">\(\sigma(k) = \frac{1}{2}k\)</span>.
That is, invest half your capital for tomorrow, and eat the rest as consumption<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>.</p>
<h2>Dynamic Programming</h2>
<p>With all that setup out of the way, let's turn to solving it.</p>
<p>Our <em>policy value function</em> is the present discounted value of following some policy <span class="math">\(\sigma\)</span> for a sequence of capital</p>
<div class="math">\begin{equation}
    v_{\sigma} = \sum_{t=0}^{\infty} \beta^t u(\sigma(k_t))
\end{equation}</div>
<p>And the <em>value function</em></p>
<div class="math">\begin{equation}
    v^*(k_0) = \sup_{\sigma \in \Sigma} v_{\sigma}(k_0)
\end{equation}</div>
<p>is the one that does best (if you haven't seen <span class="math">\(sup\)</span>, or supernum, before,  it's like the maximum).</p>
<h2>Bellman Equation</h2>
<p><em>Finally</em>, we get to the equation we'll actually work with, the <a href="https://en.wikipedia.org/wiki/Bellman_equation">Bellman equation</a>.
We've proven everything is timeless here, so we'll drop all time subscripts.
And to refer to next period values, like <span class="math">\(k_{t+1}\)</span> we'll just use a prime, <span class="math">\(k'\)</span></p>
<div class="math">\begin{equation}
    v^*(k) = \max_{0 \leq k' \leq f(k)} u(f(k) - k') + \beta v^*\left(k'\right)
\end{equation}</div>
<p>This is equation is actually simpler than is looks on first glance, and maybe more complicated than it looks on second glance.
Let's break it apart.
Our state variable is <span class="math">\(k\)</span>, so that's the only thing <span class="math">\(v\)</span> is a function of.
Our choice variable here is <span class="math">\(k'\)</span>, which is equivalent to choosing consumption <span class="math">\(c = f(k) - k'\)</span>.</p>
<p>The first term on the right-hand side is our instantaneous utility from whatever level of consumption we choose today.
More consumption is better, so less capital tomorrow (more consumption today) contributes positively to the maximization.
But, more consumption today means lower capital tomorrow, which means lower future consumption.
Indeed, we see this in second term on the right-hand side, <span class="math">\(\beta v^*(k')\)</span>.
Remember before when I asked you to lock away the intuition underlying this whole thing?
About the trade-off between consumption today and future consumption?
Well, you can take it out now.
We've now very succinctly stated that intuition in the Bellman equation.</p>
<p>One more thing, notice that <span class="math">\(v\)</span> is defined recursively, which is why I said it's maybe a bit more complicated upon a second glance.</p>
<h2>Solving it (Value Function Iteration)</h2>
<p>Holy cow is this running long, sorry.
If you've made it this far, congratulations, we'll solve it now.
We'll use a technique called value function iteration.</p>
<p>The trick is to start with some function, and successively apply an operator <span class="math">\(T\)</span>.
<span class="math">\(T\)</span> takes a function <span class="math">\(w\)</span> and returns a function <span class="math">\(Tw\)</span>, which performs better than <span class="math">\(w\)</span>.
We keep applying <span class="math">\(T\)</span> to get <span class="math">\(w, Tw, T^2w, \ldots\)</span> until it converges, and we claim victory.</p>
<p>Oh, and since we're solving this with a computer, we'll approximate the function on a discrete grid.
Here's the setup</p>
<ul>
<li><span class="math">\(f(k) = k^\alpha\)</span> where <span class="math">\(\alpha = .65\)</span></li>
<li><span class="math">\(u(c) = \ln c\)</span> (utility), and <span class="math">\(\beta = 0.95\)</span> (discount factor).</li>
</ul>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interp</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fminbound</span>

<span class="err">α</span> <span class="o">=</span> <span class="mf">0.65</span>
<span class="err">β</span> <span class="o">=</span> <span class="mf">0.95</span>

<span class="n">k_min</span><span class="p">,</span> <span class="n">k_max</span><span class="p">,</span> <span class="n">k_step</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">150</span>
<span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">k_min</span><span class="p">,</span> <span class="n">k_max</span><span class="p">,</span> <span class="n">k_step</span><span class="p">)</span>
</pre></div>


<p>Let's code up the bellman operator <span class="math">\(T\)</span>.</p>
<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    The bellman operator. T :: w -&gt; Tw. We&#39;ll also</span>
<span class="sd">    tack on the policy function saying how much k&#39;</span>
<span class="sd">    to choose given k today.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># w is a continuous function, not just on $grid$</span>
    <span class="n">Aw</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>

    <span class="n">k_opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">k_step</span><span class="p">)</span>  <span class="c1"># policy function</span>
    <span class="n">Tw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">k_step</span><span class="p">)</span>  <span class="c1"># value achieved</span>
    <span class="c1"># we&#39;ll use k_ to represent tomorrow&#39;s instead of k&#39;</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
        <span class="c1"># note the negative, we&#39;re minimizing now</span>
        <span class="n">objective</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">k_</span><span class="p">:</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="err">α</span> <span class="o">-</span> <span class="n">k_</span><span class="p">)</span> <span class="o">-</span> <span class="err">β</span> <span class="o">*</span> <span class="n">Aw</span><span class="p">(</span><span class="n">k_</span><span class="p">)</span>
        <span class="c1"># max s.t. resource constraint</span>
        <span class="n">k_star</span> <span class="o">=</span> <span class="n">fminbound</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">k_min</span><span class="p">,</span> <span class="n">k</span><span class="o">**</span><span class="err">α</span><span class="p">)</span>
        <span class="c1"># store the argmax k_star and the value at the argmax</span>
        <span class="n">k_opt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_star</span>
        <span class="n">Tw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">objective</span><span class="p">(</span><span class="n">k_star</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Tw</span><span class="p">,</span> <span class="n">k_opt</span>
</pre></div>


<p>And we can run it.
We'll collect the policy functions and value functions (evaluated on the grid)
at each iteration, and then plot the evolution.
Notice that we reassign the variable <span class="math">\(w=T(w)\)</span>, as we iterate.</p>
<div class="codehilite"><pre><span></span><span class="n">w</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">25</span>  <span class="c1"># and &quot;educated&quot; inital guess</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">35</span>  <span class="c1"># iterations</span>

<span class="c1"># let&#39;s see how they evolve</span>
<span class="n">ws</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">k_opts</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">k_opt</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="n">ws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="n">k_opts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k_opt</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">viridis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

<span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Initial Guess&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Optimal&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;capital&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$-$value&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Value Function Iteration&quot;</span><span class="p">)</span>
<span class="n">sns</span><span class="o">.</span><span class="n">despine</span><span class="p">()</span>
</pre></div>


<p><img alt="value function" src="./images/dp_value_function.svg" /></p>
<p>Notice that we rewrote the maximization problem as a minimization problem (as is typical in numerical optimization), so lower is better here.</p>
<p>We can also plot the policy function, which tells use how much capital to choose for tomorrow.</p>
<div class="codehilite"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">k_opts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$k$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$k\^{\prime}$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Policy Function&quot;</span><span class="p">)</span>
<span class="n">sns</span><span class="o">.</span><span class="n">despine</span><span class="p">()</span>
</pre></div>


<p><img alt="policy function" src="./images/dp_policy_function.svg" /></p>
<h2>Wrapup</h2>
<p>So there you have it.
You've solved a typical 1st-year PhD macro problem (skipping over tedious nuisances, like proofs).
What's the takeaway?</p>
<p>Dynamic programming is a really neat algorithm.
I love how concisely the Bellman equation showed the tradeoff between consumption today and tomorrow.
I'm always on the lookout for places to apply dynamic programming.
Typically these are complicated problems that can be split into smaller subproblems.</p>
<p>The typical football example (from <a href="http://eml.berkeley.edu//~dromer/papers/JPE_April06.pdf">David Romer</a>) is should you go for it on 4th down?
You're trying to maximize the probability of winning over all possible future paths in the game (a complicated problem), so you simplify it to given the current state of the game, which play puts me in the best position next play?
This is still pretty complicated, but dynamic programming can be used to answer "Should I go for it on 4th down?".</p>
<p>Be on the lookup for places to apply dynamic programming, and <a href="https://twitter.com/tomaugspurger">let me know</a> if you find any.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>"Programming" is used in the optimization sense (like linear or quadratic programming). We will see code later though.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Note again that <span class="math">\(\sigma\)</span> is a function.
Typically when optimizing you'll choose some scalar or vector to maximize a function.
In this case we're choosing a <em>function</em> to maximize and <em>infinite sequence</em>.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript'; 
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
  </div><!-- /.entry-content -->
</section>

    <footer>
      <p>&copy; Tom Augspurger </p>
    </footer>
  </main>

</body>
</html>